access (man 2 access)
chdir (man 2 chdir)
close (man 2 close)
closedir (man 3 closedir)
execve (man 2 execve)
exit (man 3 exit)
_exit (man 2 _exit)
fflush (man 3 fflush)
fork (man 2 fork)
free (man 3 free)
getcwd (man 3 getcwd)
getline (man 3 getline)
getpid (man 2 getpid)
isatty (man 3 isatty)
kill (man 2 kill)
malloc (man 3 malloc)
open (man 2 open)
opendir (man 3 opendir)
perror (man 3 perror)
read (man 2 read)
readdir (man 3 readdir)
signal (man 2 signal)
stat (__xstat) (man 2 stat)
lstat (__lxstat) (man 2 lstat)
fstat (__fxstat) (man 2 fstat)
strtok (man 3 strtok)
wait (man 2 wait)
waitpid (man 2 waitpid)
wait3 (man 2 wait3)
wait4 (man 2 wait4)
write (man 2 write)
ACCESS(2)                Linux Programmer's Manual               ACCESS(2)

NAME
       access, faccessat, faccessat2 - check user's permissions for a file

SYNOPSIS
       #include <unistd.h>

       int access(const char *pathname, int mode);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <unistd.h>

       int faccessat(int dirfd, const char *pathname, int mode, int flags);
                       /* But see C library/kernel differences, below */

       int faccessat2(int dirfd, const char *pathname, int mode, int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       faccessat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       access()  checks  whether  the  calling process can access the file
       pathname.  If pathname is a symbolic link, it is dereferenced.

       The mode specifies the accessibility check(s) to be performed,  and
       is either the value F_OK, or a mask consisting of the bitwise OR of
       one or more of R_OK, W_OK, and X_OK.  F_OK tests for the  existence
       of the file.  R_OK, W_OK, and X_OK test whether the file exists and
       grants read, write, and execute permissions, respectively.

       The check is done using the calling process's  real  UID  and  GID,
       rather  than  the effective IDs as is done when actually attempting
       an operation (e.g., open(2)) on the file.  Similarly, for the  root
       user,  the check uses the set of permitted capabilities rather than
       the set of effective capabilities;  and  for  non-root  users,  the
       check uses an empty set of capabilities.

       This allows set-user-ID programs and capability-endowed programs to
       easily determine the invoking user's authority.   In  other  words,
       access()  does not answer the "can I read/write/execute this file?"
       question.  It answers a slightly different question: "(assuming I'm
       a  setuid  binary)  can  the user who invoked me read/write/execute
       this file?", which gives set-user-ID programs  the  possibility  to
       prevent malicious users from causing them to read files which users
       shouldn't be able to read.

       If the calling process is privileged (i.e., its real UID is  zero),
       then an X_OK check is successful for a regular file if execute per‐
       mission is enabled for any of the file owner, group, or other.

   faccessat()
       faccessat() operates in exactly the same way  as  access(),  except
       for the differences described here.

       If  the  pathname  given in pathname is relative, then it is inter‐
       preted relative to the directory referred to by the file descriptor
       dirfd (rather than relative to the current working directory of the
       calling process, as is done by access() for a relative pathname).

       If pathname is relative and dirfd is the  special  value  AT_FDCWD,
       then pathname is interpreted relative to the current working direc‐
       tory of the calling process (like access()).

       If pathname is absolute, then dirfd is ignored.

       flags is constructed by ORing together zero or more of the  follow‐
       ing values:

       AT_EACCESS
              Perform  access  checks  using  the effective user and group
              IDs.  By default, faccessat() uses the real  IDs  (like  ac‐
              cess()).

       AT_SYMLINK_NOFOLLOW
              If  pathname  is a symbolic link, do not dereference it: in‐
              stead return information about the link itself.

       See openat(2) for an explanation of the need for faccessat().

   faccessat2()
       The description of faccessat() given above corresponds  to  POSIX.1
       and  to  the  implementation provided by glibc.  However, the glibc
       implementation was an imperfect emulation (see BUGS)  that  papered
       over  the  fact that the raw Linux faccessat() system call does not
       have a flags argument.  To allow for a proper implementation, Linux
       5.8  added  the  faccessat2() system call, which supports the flags
       argument and allows a correct  implementation  of  the  faccessat()
       wrapper function.

RETURN VALUE
       On  success (all requested permissions granted, or mode is F_OK and
       the file exists), zero is returned.  On error (at least one bit  in
       mode asked for a permission that is denied, or mode is F_OK and the
       file does not exist, or some other error occurred), -1 is returned,
       and errno is set appropriately.

ERRORS
       access() and faccessat() shall fail if:

       EACCES The  requested access would be denied to the file, or search
              permission is denied for one of the directories in the  path
              prefix of pathname.  (See also path_resolution(7).)

       ELOOP  Too  many symbolic links were encountered in resolving path‐
              name.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling sym‐
              bolic link.

       ENOTDIR
              A component used as a directory in pathname is not, in fact,
              a directory.

       EROFS  Write permission was requested for a  file  on  a  read-only
              filesystem.

       access() and faccessat() may fail if:

       EFAULT pathname points outside your accessible address space.

       EINVAL mode was incorrectly specified.

       EIO    An I/O error occurred.

       ENOMEM Insufficient kernel memory was available.

       ETXTBSY
              Write  access  was requested to an executable which is being
              executed.

       The following additional errors can occur for faccessat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname is relative and dirfd is a file  descriptor  refer‐
              ring to a file other than a directory.

VERSIONS
       faccessat()  was  added  to Linux in kernel 2.6.16; library support
       was added to glibc in version 2.4.

       faccessat2() was added to Linux in version 5.8.

CONFORMING TO
       access(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       faccessat(): POSIX.1-2008.

       faccessat2(): Linux-specific.

NOTES
       Warning: Using these calls to check if a user is authorized to, for
       example, open a file before actually doing so using open(2) creates
       a security hole, because the user might exploit the short time  in‐
       terval between checking and opening the file to manipulate it.  For
       this reason, the use of this system call should  be  avoided.   (In
       the  example just described, a safer alternative would be to tempo‐
       rarily switch the process's effective user ID to the  real  ID  and
       then call open(2).)

       access()  always dereferences symbolic links.  If you need to check
       the permissions on a symbolic link, use faccessat() with  the  flag
       AT_SYMLINK_NOFOLLOW.

       These  calls  return an error if any of the access types in mode is
       denied, even if some of the other access types in mode are  permit‐
       ted.

       If  the  calling process has appropriate privileges (i.e., is supe‐
       ruser), POSIX.1-2001 permits an implementation to indicate  success
       for  an X_OK check even if none of the execute file permission bits
       are set.  Linux does not do this.

       A file is accessible only if the permissions on each of the  direc‐
       tories  in the path prefix of pathname grant search (i.e., execute)
       access.  If any directory is inaccessible, then the  access()  call
       fails, regardless of the permissions on the file itself.

       Only  access  bits  are  checked,  not  the  file type or contents.
       Therefore, if a directory is found  to  be  writable,  it  probably
       means  that files can be created in the directory, and not that the
       directory can be written as a file.  Similarly, a DOS file  may  be
       found to be "executable," but the execve(2) call will still fail.

       These  calls  may  not work correctly on NFSv2 filesystems with UID
       mapping enabled, because UID mapping is done on the server and hid‐
       den from the client, which checks permissions.  (NFS versions 3 and
       higher perform the check on the server.)  Similar problems can  oc‐
       cur to FUSE mounts.

   C library/kernel differences
       The  raw  faccessat()  system call takes only the first three argu‐
       ments.  The AT_EACCESS and AT_SYMLINK_NOFOLLOW flags  are  actually
       implemented  within the glibc wrapper function for faccessat().  If
       either of these flags is specified, then the wrapper  function  em‐
       ploys fstatat(2) to determine access permissions, but see BUGS.

   Glibc notes
       On  older  kernels  where  faccessat() is unavailable (and when the
       AT_EACCESS and AT_SYMLINK_NOFOLLOW flags are  not  specified),  the
       glibc  wrapper  function  falls  back to the use of access().  When
       pathname is a relative pathname, glibc constructs a pathname  based
       on the symbolic link in /proc/self/fd that corresponds to the dirfd
       argument.

BUGS
       Because the Linux kernel's faccessat() system call does not support
       a  flags  argument, the glibc faccessat() wrapper function provided
       in glibc 2.32 and earlier emulates the required functionality using
       a  combination of the faccessat() system call and fstatat(2).  How‐
       ever, this emulation does not take  ACLs  into  account.   Starting
       with glibc 2.33, the wrapper function avoids this bug by making use
       of the faccessat2() system call where it is provided by the  under‐
       lying kernel.

       In  kernel  2.4 (and earlier) there is some strangeness in the han‐
       dling of X_OK tests for superuser.  If all  categories  of  execute
       permission  are disabled for a nondirectory file, then the only ac‐
       cess() test that returns -1 is when mode is specified as just X_OK;
       if  R_OK or W_OK is also specified in mode, then access() returns 0
       for such files.  Early 2.6 kernels (up to and including 2.6.3) also
       behaved in the same way as kernel 2.4.

       In  kernels  before  2.6.20,  these calls ignored the effect of the
       MS_NOEXEC flag if it was used to mount(2) the  underlying  filesys‐
       tem.  Since kernel 2.6.20, the MS_NOEXEC flag is honored.

SEE ALSO
       chmod(2), chown(2), open(2), setgid(2), setuid(2), stat(2), euidac‐
       cess(3), credentials(7), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-12-21                       ACCESS(2)
CHDIR(2)                 Linux Programmer's Manual                CHDIR(2)

NAME
       chdir, fchdir - change working directory

SYNOPSIS
       #include <unistd.h>

       int chdir(const char *path);
       int fchdir(int fd);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fchdir():
           _XOPEN_SOURCE >= 500
               || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
               || /* Glibc up to and including 2.19: */ _BSD_SOURCE

DESCRIPTION
       chdir()  changes  the  current  working  directory  of  the calling
       process to the directory specified in path.

       fchdir() is identical to chdir(); the only difference is  that  the
       directory is given as an open file descriptor.

RETURN VALUE
       On  success, zero is returned.  On error, -1 is returned, and errno
       is set appropriately.

ERRORS
       Depending on the filesystem, other errors  can  be  returned.   The
       more general errors for chdir() are listed below:

       EACCES Search  permission  is  denied  for one of the components of
              path.  (See also path_resolution(7).)

       EFAULT path points outside your accessible address space.

       EIO    An I/O error occurred.

       ELOOP  Too many symbolic links were encountered in resolving path.

       ENAMETOOLONG
              path is too long.

       ENOENT The directory specified in path does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of path is not a directory.

       The general errors for fchdir() are listed below:

       EACCES Search permission was denied on the directory open on fd.

       EBADF  fd is not a valid file descriptor.

       ENOTDIR
              fd does not refer to a directory.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD.

NOTES
       The current working directory is the starting point for  interpret‐
       ing relative pathnames (those not starting with '/').

       A  child  process created via fork(2) inherits its parent's current
       working directory.  The current working directory is left unchanged
       by execve(2).

SEE ALSO
       chroot(2), getcwd(3), path_resolution(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2019-08-02                        CHDIR(2)
CLOSE(2)                 Linux Programmer's Manual                CLOSE(2)

NAME
       close - close a file descriptor

SYNOPSIS
       #include <unistd.h>

       int close(int fd);

DESCRIPTION
       close()  closes  a  file descriptor, so that it no longer refers to
       any file and may be reused.  Any record locks (see  fcntl(2))  held
       on  the  file it was associated with, and owned by the process, are
       removed (regardless of the file descriptor that was used to  obtain
       the lock).

       If  fd is the last file descriptor referring to the underlying open
       file description (see open(2)), the resources associated  with  the
       open  file  description  are  freed; if the file descriptor was the
       last reference to a file which has been  removed  using  unlink(2),
       the file is deleted.

RETURN VALUE
       close() returns zero on success.  On error, -1 is returned, and er‐
       rno is set appropriately.

ERRORS
       EBADF  fd isn't a valid open file descriptor.

       EINTR  The close() call was interrupted by a signal; see signal(7).

       EIO    An I/O error occurred.

       ENOSPC, EDQUOT
              On NFS, these errors are not normally reported  against  the
              first  write  which exceeds the available storage space, but
              instead against a subsequent write(2), fsync(2), or close().

       See NOTES for a discussion of why close() should not be retried af‐
       ter an error.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

NOTES
       A  successful  close does not guarantee that the data has been suc‐
       cessfully saved to disk, as the kernel uses the buffer cache to de‐
       fer  writes.   Typically,  filesystems  do not flush buffers when a
       file is closed.  If you need to be sure that the data is physically
       stored  on  the  underlying disk, use fsync(2).  (It will depend on
       the disk hardware at this point.)

       The close-on-exec file descriptor flag can be used to ensure that a
       file  descriptor  is  automatically  closed  upon  a successful ex‐
       ecve(2); see fcntl(2) for details.

   Multithreaded processes and close()
       It is probably unwise to close file descriptors while they  may  be
       in use by system calls in other threads in the same process.  Since
       a file descriptor may be reused, there are some obscure race condi‐
       tions that may cause unintended side effects.

       Furthermore,  consider the following scenario where two threads are
       performing operations on the same file descriptor:

       1. One thread is blocked in an I/O system call on the file descrip‐
          tor.   For  example,  it is trying to write(2) to a pipe that is
          already full, or trying to read(2) from a  stream  socket  which
          currently has no available data.

       2. Another thread closes the file descriptor.

       The behavior in this situation varies across systems.  On some sys‐
       tems, when the file descriptor is closed, the blocking system  call
       returns immediately with an error.

       On Linux (and possibly some other systems), the behavior is differ‐
       ent.  the blocking I/O system call holds a reference to the  under‐
       lying  open file description, and this reference keeps the descrip‐
       tion open until the I/O system call completes.  (See open(2) for  a
       discussion  of  open file descriptions.)  Thus, the blocking system
       call in the  first  thread  may  successfully  complete  after  the
       close() in the second thread.

   Dealing with error returns from close()
       A  careful programmer will check the return value of close(), since
       it is quite possible that errors on a previous  write(2)  operation
       are  reported only on the final close() that releases the open file
       description.  Failing to check the return value when closing a file
       may  lead  to silent loss of data.  This can especially be observed
       with NFS and with disk quota.

       Note, however, that a failure return should be used only for  diag‐
       nostic  purposes (i.e., a warning to the application that there may
       still be I/O pending or there may have been failed I/O) or remedial
       purposes (e.g., writing the file once more or creating a backup).

       Retrying  the  close() after a failure return is the wrong thing to
       do, since this may cause a  reused  file  descriptor  from  another
       thread  to  be closed.  This can occur because the Linux kernel al‐
       ways releases the file descriptor early  in  the  close  operation,
       freeing  it  for reuse; the steps that may return an error, such as
       flushing data to the filesystem or device, occur only later in  the
       close operation.

       Many other implementations similarly always close the file descrip‐
       tor (except in the case of EBADF, meaning that the file  descriptor
       was  invalid)  even  if they subsequently report an error on return
       from close().  POSIX.1 is currently silent on this point, but there
       are plans to mandate this behavior in the next major release of the
       standard.

       A careful programmer who wants to know about I/O errors may precede
       close() with a call to fsync(2).

       The  EINTR  error  is a somewhat special case.  Regarding the EINTR
       error, POSIX.1-2008 says:

              If close() is interrupted by a signal that is to be  caught,
              it  shall return -1 with errno set to EINTR and the state of
              fildes is unspecified.

       This permits the behavior that occurs on Linux and many  other  im‐
       plementations,  where, as with other errors that may be reported by
       close(), the file descriptor is guaranteed to be closed.   However,
       it  also  permits  another possibility: that the implementation re‐
       turns an EINTR error and keeps the file descriptor open.   (Accord‐
       ing  to  its documentation, HP-UX's close() does this.)  The caller
       must then once more use close() to close the  file  descriptor,  to
       avoid file descriptor leaks.  This divergence in implementation be‐
       haviors provides a  difficult  hurdle  for  portable  applications,
       since on many implementations, close() must not be called again af‐
       ter an EINTR error, and on at least one,  close()  must  be  called
       again.   There are plans to address this conundrum for the next ma‐
       jor release of the POSIX.1 standard.

SEE ALSO
       fcntl(2), fsync(2), open(2), shutdown(2), unlink(2), fclose(3)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-06-09                        CLOSE(2)
EXECVE(2)                Linux Programmer's Manual               EXECVE(2)

NAME
       execve - execute program

SYNOPSIS
       #include <unistd.h>

       int execve(const char *pathname, char *const argv[],
                  char *const envp[]);

DESCRIPTION
       execve() executes the program referred to by pathname.  This causes
       the program that is currently being run by the calling  process  to
       be replaced with a new program, with newly initialized stack, heap,
       and (initialized and uninitialized) data segments.

       pathname must be either a binary executable, or a  script  starting
       with a line of the form:

           #!interpreter [optional-arg]

       For details of the latter case, see "Interpreter scripts" below.

       argv  is  an array of pointers to strings passed to the new program
       as its command-line arguments.  By convention, the first  of  these
       strings (i.e., argv[0]) should contain the filename associated with
       the file being executed.  The argv array must be  terminated  by  a
       NULL pointer.  (Thus, in the new program, argv[argc] will be NULL.)

       envp is an array of pointers to strings, conventionally of the form
       key=value, which are passed as the environment of the new  program.
       The envp array must be terminated by a NULL pointer.

       The argument vector and environment can be accessed by the new pro‐
       gram's main function, when it is defined as:

           int main(int argc, char *argv[], char *envp[])

       Note, however, that the use of a third argument to the  main  func‐
       tion  is  not specified in POSIX.1; according to POSIX.1, the envi‐
       ronment should be accessed via the external variable environ(7).

       execve() does not return on  success,  and  the  text,  initialized
       data,  uninitialized  data  (bss), and stack of the calling process
       are overwritten according to the contents of the newly loaded  pro‐
       gram.

       If  the  current program is being ptraced, a SIGTRAP signal is sent
       to it after a successful execve().

       If the set-user-ID bit is set on the program file  referred  to  by
       pathname,  then  the  effective  user  ID of the calling process is
       changed to that of the owner of the program  file.   Similarly,  if
       the set-group-ID bit is set on the program file, then the effective
       group ID of the calling process is set to the group of the  program
       file.

       The  aforementioned  transformations  of  the effective IDs are not
       performed (i.e., the set-user-ID and set-group-ID bits are ignored)
       if any of the following is true:

       *  the  no_new_privs  attribute  is set for the calling thread (see
          prctl(2));

       *  the underlying filesystem is mounted nosuid (the MS_NOSUID  flag
          for mount(2)); or

       *  the calling process is being ptraced.

       The capabilities of the program file (see capabilities(7)) are also
       ignored if any of the above are true.

       The effective user ID of the process is copied to  the  saved  set-
       user-ID;  similarly,  the effective group ID is copied to the saved
       set-group-ID.  This copying takes  place  after  any  effective  ID
       changes that occur because of the set-user-ID and set-group-ID mode
       bits.

       The process's real UID and real  GID,  as  well  its  supplementary
       group IDs, are unchanged by a call to execve().

       If  the executable is an a.out dynamically linked binary executable
       containing shared-library stubs, the Linux dynamic linker  ld.so(8)
       is  called at the start of execution to bring needed shared objects
       into memory and link the executable with them.

       If the executable is a dynamically linked ELF executable,  the  in‐
       terpreter named in the PT_INTERP segment is used to load the needed
       shared objects.  This interpreter is  typically  /lib/ld-linux.so.2
       for binaries linked with glibc (see ld-linux.so(8)).

   Effect on process attributes
       All process attributes are preserved during an execve(), except the
       following:

       *  The dispositions of any signals that are being caught are  reset
          to the default (signal(7)).

       *  Any alternate signal stack is not preserved (sigaltstack(2)).

       *  Memory mappings are not preserved (mmap(2)).

       *  Attached   System V   shared   memory   segments   are  detached
          (shmat(2)).

       *  POSIX shared memory regions are unmapped (shm_open(3)).

       *  Open  POSIX  message  queue  descriptors  are  closed  (mq_over‐
          view(7)).

       *  Any open POSIX named semaphores are closed (sem_overview(7)).

       *  POSIX timers are not preserved (timer_create(2)).

       *  Any open directory streams are closed (opendir(3)).

       *  Memory locks are not preserved (mlock(2), mlockall(2)).

       *  Exit handlers are not preserved (atexit(3), on_exit(3)).

       *  The  floating-point  environment  is  reset  to the default (see
          fenv(3)).

       The process attributes in the preceding list are all  specified  in
       POSIX.1.   The following Linux-specific process attributes are also
       not preserved during an execve():

       *  The process's "dumpable" attribute is set to the value 1, unless
          a set-user-ID program, a set-group-ID program, or a program with
          capabilities is being executed, in which case the dumpable  flag
          may instead be reset to the value in /proc/sys/fs/suid_dumpable,
          in  the  circumstances  described   under   PR_SET_DUMPABLE   in
          prctl(2).   Note  that  changes  to the "dumpable" attribute may
          cause ownership of files in the process's /proc/[pid]  directory
          to change to root:root, as described in proc(5).

       *  The prctl(2) PR_SET_KEEPCAPS flag is cleared.

       *  (Since  Linux  2.4.36 / 2.6.23) If a set-user-ID or set-group-ID
          program is being executed, then the parent death signal  set  by
          prctl(2) PR_SET_PDEATHSIG flag is cleared.

       *  The  process name, as set by prctl(2) PR_SET_NAME (and displayed
          by ps -o comm), is reset to the name of the new executable file.

       *  The SECBIT_KEEP_CAPS securebits flag is cleared.  See  capabili‐
          ties(7).

       *  The termination signal is reset to SIGCHLD (see clone(2)).

       *  The file descriptor table is unshared, undoing the effect of the
          CLONE_FILES flag of clone(2).

       Note the following further points:

       *  All threads other than the calling thread are  destroyed  during
          an  execve().   Mutexes, condition variables, and other pthreads
          objects are not preserved.

       *  The equivalent of setlocale(LC_ALL, "C") is executed at  program
          start-up.

       *  POSIX.1  specifies that the dispositions of any signals that are
          ignored or set to the default are left unchanged.  POSIX.1 spec‐
          ifies one exception: if SIGCHLD is being ignored, then an imple‐
          mentation may leave the disposition unchanged or reset it to the
          default; Linux does the former.

       *  Any   outstanding   asynchronous  I/O  operations  are  canceled
          (aio_read(3), aio_write(3)).

       *  For the handling of capabilities during execve(), see  capabili‐
          ties(7).

       *  By  default,  file  descriptors  remain open across an execve().
          File descriptors that are marked close-on-exec are  closed;  see
          the  description of FD_CLOEXEC in fcntl(2).  (If a file descrip‐
          tor is closed, this will cause the release of all  record  locks
          obtained  on  the underlying file by this process.  See fcntl(2)
          for details.)  POSIX.1 says that if file descriptors 0, 1, and 2
          would  otherwise  be closed after a successful execve(), and the
          process would gain privilege because  the  set-user-ID  or  set-
          group-ID  mode bit was set on the executed file, then the system
          may open an unspecified file for each of these file descriptors.
          As  a general principle, no portable program, whether privileged
          or not, can assume that these three file descriptors will remain
          closed across an execve().

   Interpreter scripts
       An  interpreter  script  is a text file that has execute permission
       enabled and whose first line is of the form:

           #!interpreter [optional-arg]

       The interpreter must be a valid pathname for an executable file.

       If the pathname  argument  of  execve()  specifies  an  interpreter
       script,  then  interpreter will be invoked with the following argu‐
       ments:

           interpreter [optional-arg] pathname arg...

       where pathname is the absolute pathname of the  file  specified  as
       the  first argument of execve(), and arg...  is the series of words
       pointed to by the argv argument of execve(), starting  at  argv[1].
       Note that there is no way to get the argv[0] that was passed to the
       execve() call.

       For portable use, optional-arg should either be absent, or be spec‐
       ified  as  a single word (i.e., it should not contain white space);
       see NOTES below.

       Since Linux 2.6.28, the kernel permits the interpreter of a  script
       to itself be a script.  This permission is recursive, up to a limit
       of four recursions, so that the interpreter may be a  script  which
       is interpreted by a script, and so on.

   Limits on size of arguments and environment
       Most  UNIX  implementations  impose some limit on the total size of
       the command-line argument (argv)  and  environment  (envp)  strings
       that may be passed to a new program.  POSIX.1 allows an implementa‐
       tion to advertise this limit using the ARG_MAX constant (either de‐
       fined  in  <limits.h>  or  available  at  run  time  using the call
       sysconf(_SC_ARG_MAX)).

       On Linux prior to kernel 2.6.23, the memory used to store the envi‐
       ronment  and  argument  strings was limited to 32 pages (defined by
       the kernel constant MAX_ARG_PAGES).  On architectures with  a  4-kB
       page size, this yields a maximum size of 128 kB.

       On kernel 2.6.23 and later, most architectures support a size limit
       derived from  the  soft  RLIMIT_STACK  resource  limit  (see  getr‐
       limit(2))  that is in force at the time of the execve() call.  (Ar‐
       chitectures with no memory management unit are excepted: they main‐
       tain  the  limit  that  was  in effect before kernel 2.6.23.)  This
       change allows programs to have a much larger argument and/or  envi‐
       ronment  list.   For these architectures, the total size is limited
       to 1/4 of the allowed stack size.  (Imposing the 1/4-limit  ensures
       that  the  new program always has some stack space.)  Additionally,
       the total size is limited to 3/4 of the value of  the  kernel  con‐
       stant  _STK_LIM (8 Mibibytes).  Since Linux 2.6.25, the kernel also
       places a floor of 32 pages on this size limit, so that,  even  when
       RLIMIT_STACK  is  set very low, applications are guaranteed to have
       at least as much argument and environment space as was provided  by
       Linux  2.6.23  and  earlier.   (This  guarantee was not provided in
       Linux 2.6.23 and 2.6.24.)  Additionally, the limit per string is 32
       pages  (the kernel constant MAX_ARG_STRLEN), and the maximum number
       of strings is 0x7FFFFFFF.

RETURN VALUE
       On success, execve() does not return, on error -1 is returned,  and
       errno is set appropriately.

ERRORS
       E2BIG  The  total number of bytes in the environment (envp) and ar‐
              gument list (argv) is too large.

       EACCES Search permission is denied on a component of the path  pre‐
              fix  of  pathname or the name of a script interpreter.  (See
              also path_resolution(7).)

       EACCES The file or a script interpreter is not a regular file.

       EACCES Execute permission is denied for the file or a script or ELF
              interpreter.

       EACCES The filesystem is mounted noexec.

       EAGAIN (since Linux 3.1)
              Having  changed  its  real  UID  using  one of the set*uid()
              calls,  the  caller   was—and   is   now   still—above   its
              RLIMIT_NPROC  resource limit (see setrlimit(2)).  For a more
              detailed explanation of this error, see NOTES.

       EFAULT pathname or one of the pointers in the vectors argv or  envp
              points outside your accessible address space.

       EINVAL An ELF executable had more than one PT_INTERP segment (i.e.,
              tried to name more than one interpreter).

       EIO    An I/O error occurred.

       EISDIR An ELF interpreter was a directory.

       ELIBBAD
              An ELF interpreter was not in a recognized format.

       ELOOP  Too many symbolic links were encountered in resolving  path‐
              name or the name of a script or ELF interpreter.

       ELOOP  The  maximum  recursion  limit  was reached during recursive
              script interpretation (see  "Interpreter  scripts",  above).
              Before  Linux  3.8,  the  error  produced  for this case was
              ENOEXEC.

       EMFILE The per-process limit on the number of open file descriptors
              has been reached.

       ENAMETOOLONG
              pathname is too long.

       ENFILE The  system-wide limit on the total number of open files has
              been reached.

       ENOENT The file pathname or a script or ELF  interpreter  does  not
              exist.

       ENOEXEC
              An  executable  is  not  in  a recognized format, is for the
              wrong architecture, or has  some  other  format  error  that
              means it cannot be executed.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A  component  of  the path prefix of pathname or a script or
              ELF interpreter is not a directory.

       EPERM  The filesystem is mounted nosuid, the user is not the  supe‐
              ruser,  and the file has the set-user-ID or set-group-ID bit
              set.

       EPERM  The process is being traced, the user is not  the  superuser
              and the file has the set-user-ID or set-group-ID bit set.

       EPERM  A  "capability-dumb"  applications would not obtain the full
              set of permitted  capabilities  granted  by  the  executable
              file.  See capabilities(7).

       ETXTBSY
              The specified executable was open for writing by one or more
              processes.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX does not  document
       the #! behavior, but it exists (with some variations) on other UNIX
       systems.

NOTES
       One sometimes sees execve() (and the related functions described in
       exec(3)) described as "executing a new process" (or similar).  This
       is a highly misleading description: there is no new  process;  many
       attributes  of the calling process remain unchanged (in particular,
       its PID).  All that  execve()  does  is  arrange  for  an  existing
       process (the calling process) to execute a new program.

       Set-user-ID and set-group-ID processes can not be ptrace(2)d.

       The result of mounting a filesystem nosuid varies across Linux ker‐
       nel versions: some will refuse execution of  set-user-ID  and  set-
       group-ID  executables when this would give the user powers they did
       not have already (and return EPERM), some will just ignore the set-
       user-ID and set-group-ID bits and exec() successfully.

       On  Linux,  argv and envp can be specified as NULL.  In both cases,
       this has the same effect as specifying the argument as a pointer to
       a  list containing a single null pointer.  Do not take advantage of
       this nonstandard and nonportable misfeature!  On  many  other  UNIX
       systems,  specifying argv as NULL will result in an error (EFAULT).
       Some other UNIX systems treat  the  envp==NULL  case  the  same  as
       Linux.

       POSIX.1 says that values returned by sysconf(3) should be invariant
       over the lifetime of a process.  However, since  Linux  2.6.23,  if
       the RLIMIT_STACK resource limit changes, then the value reported by
       _SC_ARG_MAX will also change, to reflect the fact that the limit on
       space  for holding command-line arguments and environment variables
       has changed.

       In most cases where execve() fails, control returns to the original
       executable  image,  and  the caller of execve() can then handle the
       error.  However, in (rare) cases (typically caused by resource  ex‐
       haustion), failure may occur past the point of no return: the orig‐
       inal executable image has been torn down, but the new  image  could
       not  be  completely  built.   In  such  cases, the kernel kills the
       process with a SIGSEGV (SIGKILL until Linux 3.17) signal.

   Interpreter scripts
       The kernel imposes a maximum length on the text  that  follows  the
       "#!"  characters  at  the  start of a script; characters beyond the
       limit are ignored.  Before Linux 5.1, the limit is 127  characters.
       Since Linux 5.1, the limit is 255 characters.

       The semantics of the optional-arg argument of an interpreter script
       vary across implementations.  On Linux, the entire string following
       the  interpreter  name is passed as a single argument to the inter‐
       preter, and this string can include white space.  However, behavior
       differs  on  some  other systems.  Some systems use the first white
       space to terminate optional-arg.  On some systems,  an  interpreter
       script  can  have multiple arguments, and white spaces in optional-
       arg are used to delimit the arguments.

       Linux (like most other modern UNIX systems) ignores the set-user-ID
       and set-group-ID bits on scripts.

   execve() and EAGAIN
       A  more  detailed  explanation  of  the EAGAIN error that can occur
       (since Linux 3.1) when calling execve() is as follows.

       The EAGAIN error can occur when a preceding call to setuid(2),  se‐
       treuid(2),  or  setresuid(2) caused the real user ID of the process
       to change, and  that  change  caused  the  process  to  exceed  its
       RLIMIT_NPROC  resource limit (i.e., the number of processes belong‐
       ing to the new real UID exceeds the resource  limit).   From  Linux
       2.6.0  to  3.0,  this caused the set*uid() call to fail.  (Prior to
       2.6, the resource limit was not imposed on processes  that  changed
       their user IDs.)

       Since  Linux  3.1, the scenario just described no longer causes the
       set*uid() call to fail, because it too often led to security  holes
       where buggy applications didn't check the return status and assumed
       that—if the caller had root privileges—the call would  always  suc‐
       ceed.   Instead,  the  set*uid()  calls now successfully change the
       real UID, but the kernel sets an internal flag, named  PF_NPROC_EX‐
       CEEDED,  to  note that the RLIMIT_NPROC resource limit has been ex‐
       ceeded.  If the PF_NPROC_EXCEEDED flag  is  set  and  the  resource
       limit  is still exceeded at the time of a subsequent execve() call,
       that call fails with the error EAGAIN.  This kernel  logic  ensures
       that the RLIMIT_NPROC resource limit is still enforced for the com‐
       mon privileged daemon workflow—namely, fork(2) +  set*uid()  +  ex‐
       ecve().

       If the resource limit was not still exceeded at the time of the ex‐
       ecve() call (because other processes belonging  to  this  real  UID
       terminated  between the set*uid() call and the execve() call), then
       the execve() call succeeds and the kernel clears  the  PF_NPROC_EX‐
       CEEDED process flag.  The flag is also cleared if a subsequent call
       to fork(2) by this process succeeds.

   Historical
       With UNIX V6, the argument list of an exec() call was ended  by  0,
       while  the argument list of main was ended by -1.  Thus, this argu‐
       ment list was not directly usable in a further exec() call.   Since
       UNIX V7, both are NULL.

EXAMPLES
       The  following  program is designed to be execed by the second pro‐
       gram below.  It just echoes its  command-line  arguments,  one  per
       line.

           /* myecho.c */

           #include <stdio.h>
           #include <stdlib.h>

           int
           main(int argc, char *argv[])
           {
               for (int j = 0; j < argc; j++)
                   printf("argv[%d]: %s\n", j, argv[j]);

               exit(EXIT_SUCCESS);
           }

       This  program can be used to exec the program named in its command-
       line argument:

           /* execve.c */

           #include <stdio.h>
           #include <stdlib.h>
           #include <unistd.h>

           int
           main(int argc, char *argv[])
           {
               char *newargv[] = { NULL, "hello", "world", NULL };
               char *newenviron[] = { NULL };

               if (argc != 2) {
                   fprintf(stderr, "Usage: %s <file-to-exec>\n", argv[0]);
                   exit(EXIT_FAILURE);
               }

               newargv[0] = argv[1];

               execve(argv[1], newargv, newenviron);
               perror("execve");   /* execve() returns only on error */
               exit(EXIT_FAILURE);
           }

       We can use the second program to exec the first as follows:

           $ cc myecho.c -o myecho
           $ cc execve.c -o execve
           $ ./execve ./myecho
           argv[0]: ./myecho
           argv[1]: hello
           argv[2]: world

       We can also use these programs to demonstrate the use of  a  script
       interpreter.   To do this we create a script whose "interpreter" is
       our myecho program:

           $ cat > script
           #!./myecho script-arg
           ^D
           $ chmod +x script

       We can then use our program to exec the script:

           $ ./execve ./script
           argv[0]: ./myecho
           argv[1]: script-arg
           argv[2]: ./script
           argv[3]: hello
           argv[4]: world

SEE ALSO
       chmod(2),  execveat(2),  fork(2),  get_robust_list(2),   ptrace(2),
       exec(3), fexecve(3), getopt(3), system(3), capabilities(7), creden‐
       tials(7), environ(7), path_resolution(7), ld.so(8)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-08-13                       EXECVE(2)
EXIT(3)                  Linux Programmer's Manual                 EXIT(3)

NAME
       exit - cause normal process termination

SYNOPSIS
       #include <stdlib.h>

       void exit(int status);

DESCRIPTION
       The exit() function causes normal process termination and the least
       significant byte of status (i.e., status & 0xFF) is returned to the
       parent (see wait(2)).

       All  functions registered with atexit(3) and on_exit(3) are called,
       in the reverse order of their registration.  (It  is  possible  for
       one  of  these functions to use atexit(3) or on_exit(3) to register
       an additional function to be executed during exit  processing;  the
       new  registration  is  added  to the front of the list of functions
       that remain to be called.)  If one of these functions does not  re‐
       turn (e.g., it calls _exit(2), or kills itself with a signal), then
       none of the remaining functions is called, and  further  exit  pro‐
       cessing (in particular, flushing of stdio(3) streams) is abandoned.
       If a function has been registered multiple times using atexit(3) or
       on_exit(3), then it is called as many times as it was registered.

       All open stdio(3) streams are flushed and closed.  Files created by
       tmpfile(3) are removed.

       The C standard specifies two constants, EXIT_SUCCESS and EXIT_FAIL‐
       URE,  that may be passed to exit() to indicate successful or unsuc‐
       cessful termination, respectively.

RETURN VALUE
       The exit() function does not return.

ATTRIBUTES
       For an explanation of the terms  used  in  this  section,  see  at‐
       tributes(7).

       ┌──────────┬───────────────┬─────────────────────┐
       │Interface │ Attribute     │ Value               │
       ├──────────┼───────────────┼─────────────────────┤
       │exit()    │ Thread safety │ MT-Unsafe race:exit │
       └──────────┴───────────────┴─────────────────────┘
       The  exit()  function uses a global variable that is not protected,
       so it is not thread-safe.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

NOTES
       The behavior is undefined if one of the functions registered  using
       atexit(3)  and  on_exit(3) calls either exit() or longjmp(3).  Note
       that a  call  to  execve(2)  removes  registrations  created  using
       atexit(3) and on_exit(3).

       The  use of EXIT_SUCCESS and EXIT_FAILURE is slightly more portable
       (to non-UNIX environments) than the use of 0 and some nonzero value
       like 1 or -1.  In particular, VMS uses a different convention.

       BSD has attempted to standardize exit codes (which some C libraries
       such as the GNU C library have also adopted); see the file  <sysex‐
       its.h>.

       After  exit(),  the  exit  status must be transmitted to the parent
       process.  There are three cases:

       •  If the parent has set SA_NOCLDWAIT, or has set the SIGCHLD  han‐
          dler  to SIG_IGN, the status is discarded and the child dies im‐
          mediately.

       •  If the parent was waiting on the child, it is  notified  of  the
          exit status and the child dies immediately.

       •  Otherwise,  the  child  becomes  a "zombie" process: most of the
          process resources are recycled, but a  slot  containing  minimal
          information  about  the  child  process (termination status, re‐
          source usage statistics) is retained in process table.  This al‐
          lows  the  parent to subsequently use waitpid(2) (or similar) to
          learn the termination status of the child;  at  that  point  the
          zombie process slot is released.

       If  the  implementation supports the SIGCHLD signal, this signal is
       sent to the parent.  If the parent has set SA_NOCLDWAIT, it is  un‐
       defined whether a SIGCHLD signal is sent.

   Signals sent to other processes
       If the exiting process is a session leader and its controlling ter‐
       minal is the controlling terminal of the session, then each process
       in  the  foreground  process  group of this controlling terminal is
       sent a SIGHUP signal, and the terminal is disassociated  from  this
       session, allowing it to be acquired by a new controlling process.

       If  the  exit  of  the process causes a process group to become or‐
       phaned, and if any member of the newly orphaned  process  group  is
       stopped,  then a SIGHUP signal followed by a SIGCONT signal will be
       sent to each process in this process group.  See setpgid(2) for  an
       explanation of orphaned process groups.

       Except  in  the  above  cases, where the signalled processes may be
       children of the terminating process, termination of a process  does
       not  in  general  cause  a  signal  to  be sent to children of that
       process.  However, a process can use the prctl(2)  PR_SET_PDEATHSIG
       operation to arrange that it receives a signal if its parent termi‐
       nates.

SEE ALSO
       _exit(2),  get_robust_list(2),  setpgid(2),   wait(2),   atexit(3),
       on_exit(3), tmpfile(3)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-02-09                         EXIT(3)
_EXIT(2)                 Linux Programmer's Manual                _EXIT(2)

NAME
       _exit, _Exit - terminate the calling process

SYNOPSIS
       #include <unistd.h>

       void _exit(int status);

       #include <stdlib.h>

       void _Exit(int status);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       _Exit():
           _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L

DESCRIPTION
       _exit()  terminates  the  calling  process "immediately".  Any open
       file descriptors belonging to the process are closed.  Any children
       of  the  process  are inherited by init(1) (or by the nearest "sub‐
       reaper"  process  as  defined  through  the  use  of  the  prctl(2)
       PR_SET_CHILD_SUBREAPER  operation).  The process's parent is sent a
       SIGCHLD signal.

       The value status & 0xFF is returned to the parent  process  as  the
       process's exit status, and can be collected by the parent using one
       of the wait(2) family of calls.

       The function _Exit() is equivalent to _exit().

RETURN VALUE
       These functions do not return.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  The function _Exit() was
       introduced by C99.

NOTES
       For  a  discussion  on  the effects of an exit, the transmission of
       exit status,  zombie  processes,  signals  sent,  and  so  on,  see
       exit(3).

       The  function  _exit() is like exit(3), but does not call any func‐
       tions registered  with  atexit(3)  or  on_exit(3).   Open  stdio(3)
       streams  are  not  flushed.   On the other hand, _exit() does close
       open file descriptors, and this may cause an unknown delay, waiting
       for pending output to finish.  If the delay is undesired, it may be
       useful to call functions like tcflush(3)  before  calling  _exit().
       Whether  any  pending I/O is canceled, and which pending I/O may be
       canceled upon _exit(), is implementation-dependent.

   C library/kernel differences
       In glibc up to version 2.3, the _exit()  wrapper  function  invoked
       the  kernel  system  call  of  the same name.  Since glibc 2.3, the
       wrapper function invokes exit_group(2), in order to  terminate  all
       of  the  threads in a process.  (The raw _exit() system call termi‐
       nates only the calling thread.)

SEE ALSO
       execve(2),  exit_group(2),  fork(2),  kill(2),  wait(2),  wait4(2),
       waitpid(2), atexit(3), exit(3), on_exit(3), termios(3)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-02-09                        _EXIT(2)
FFLUSH(3)                Linux Programmer's Manual               FFLUSH(3)

NAME
       fflush - flush a stream

SYNOPSIS
       #include <stdio.h>

       int fflush(FILE *stream);

DESCRIPTION
       For  output  streams,  fflush()  forces  a  write of all user-space
       buffered data for  the  given  output  or  update  stream  via  the
       stream's underlying write function.

       For input streams associated with seekable files (e.g., disk files,
       but not pipes or terminals), fflush() discards  any  buffered  data
       that  has  been  fetched from the underlying file, but has not been
       consumed by the application.

       The open status of the stream is unaffected.

       If the stream argument is NULL, fflush() flushes  all  open  output
       streams.

       For a nonlocking counterpart, see unlocked_stdio(3).

RETURN VALUE
       Upon  successful  completion  0 is returned.  Otherwise, EOF is re‐
       turned and errno is set to indicate the error.

ERRORS
       EBADF  stream is not an open stream, or is not open for writing.

       The function fflush() may also fail and set errno for  any  of  the
       errors specified for write(2).

ATTRIBUTES
       For  an  explanation  of  the  terms  used in this section, see at‐
       tributes(7).

       ┌──────────┬───────────────┬─────────┐
       │Interface │ Attribute     │ Value   │
       ├──────────┼───────────────┼─────────┤
       │fflush()  │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘
CONFORMING TO
       C89, C99, POSIX.1-2001, POSIX.1-2008.

       POSIX.1-2001 did not specify the behavior  for  flushing  of  input
       streams, but the behavior is specified in POSIX.1-2008.

NOTES
       Note  that fflush() flushes only the user-space buffers provided by
       the C library.  To ensure that the data  is  physically  stored  on
       disk  the  kernel  buffers  must  be flushed too, for example, with
       sync(2) or fsync(2).

SEE ALSO
       fsync(2), sync(2), write(2), fclose(3), fileno(3),  fopen(3),  set‐
       buf(3), unlocked_stdio(3)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

GNU                             2017-09-15                       FFLUSH(3)
FORK(2)                  Linux Programmer's Manual                 FORK(2)

NAME
       fork - create a child process

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       pid_t fork(void);

DESCRIPTION
       fork()  creates  a  new process by duplicating the calling process.
       The new process is referred to as the child process.   The  calling
       process is referred to as the parent process.

       The  child  process  and  the parent process run in separate memory
       spaces.  At the time of fork() both memory  spaces  have  the  same
       content.   Memory  writes,  file mappings (mmap(2)), and unmappings
       (munmap(2)) performed by one of the processes  do  not  affect  the
       other.

       The  child  process is an exact duplicate of the parent process ex‐
       cept for the following points:

       *  The child has its own unique process ID, and this PID  does  not
          match  the ID of any existing process group (setpgid(2)) or ses‐
          sion.

       *  The child's parent process  ID  is  the  same  as  the  parent's
          process ID.

       *  The  child does not inherit its parent's memory locks (mlock(2),
          mlockall(2)).

       *  Process resource utilizations (getrusage(2)) and CPU time  coun‐
          ters (times(2)) are reset to zero in the child.

       *  The  child's set of pending signals is initially empty (sigpend‐
          ing(2)).

       *  The child does not inherit semaphore adjustments from its parent
          (semop(2)).

       *  The  child does not inherit process-associated record locks from
          its parent (fcntl(2)).  (On the other hand, it does inherit  fc‐
          ntl(2)  open  file description locks and flock(2) locks from its
          parent.)

       *  The child does not inherit timers from its parent (setitimer(2),
          alarm(2), timer_create(2)).

       *  The  child  does not inherit outstanding asynchronous I/O opera‐
          tions from its parent (aio_read(3), aio_write(3)), nor  does  it
          inherit  any  asynchronous  I/O  contexts  from  its parent (see
          io_setup(2)).

       The process attributes in the preceding list are all  specified  in
       POSIX.1.  The parent and child also differ with respect to the fol‐
       lowing Linux-specific process attributes:

       *  The child does not inherit directory change notifications  (dno‐
          tify)  from  its  parent (see the description of F_NOTIFY in fc‐
          ntl(2)).

       *  The prctl(2) PR_SET_PDEATHSIG setting is reset so that the child
          does not receive a signal when its parent terminates.

       *  The  default  timer  slack  value is set to the parent's current
          timer slack value.  See the description of PR_SET_TIMERSLACK  in
          prctl(2).

       *  Memory  mappings  that  have  been  marked  with  the madvise(2)
          MADV_DONTFORK flag are not inherited across a fork().

       *  Memory in address ranges that have been  marked  with  the  mad‐
          vise(2)  MADV_WIPEONFORK  flag  is  zeroed  in the child after a
          fork().  (The MADV_WIPEONFORK setting remains in place for those
          address ranges in the child.)

       *  The  termination  signal  of  the  child  is always SIGCHLD (see
          clone(2)).

       *  The port access permission bits set by ioperm(2) are not  inher‐
          ited  by  the child; the child must turn on any bits that it re‐
          quires using ioperm(2).

       Note the following further points:

       *  The child process is created with a single thread—the  one  that
          called  fork().   The entire virtual address space of the parent
          is replicated in the child, including  the  states  of  mutexes,
          condition  variables,  and  other  pthreads  objects; the use of
          pthread_atfork(3) may be helpful for dealing with problems  that
          this can cause.

       *  After  a fork() in a multithreaded program, the child can safely
          call only async-signal-safe functions (see signal-safety(7)) un‐
          til such time as it calls execve(2).

       *  The  child  inherits copies of the parent's set of open file de‐
          scriptors.  Each file descriptor in the child refers to the same
          open  file  description  (see open(2)) as the corresponding file
          descriptor in the parent.  This means that the two file descrip‐
          tors  share  open  file  status  flags, file offset, and signal-
          driven I/O attributes  (see  the  description  of  F_SETOWN  and
          F_SETSIG in fcntl(2)).

       *  The  child  inherits  copies of the parent's set of open message
          queue descriptors (see mq_overview(7)).  Each file descriptor in
          the  child  refers to the same open message queue description as
          the corresponding file descriptor in  the  parent.   This  means
          that the two file descriptors share the same flags (mq_flags).

       *  The  child inherits copies of the parent's set of open directory
          streams (see opendir(3)).  POSIX.1 says that  the  corresponding
          directory  streams  in the parent and child may share the direc‐
          tory stream positioning; on Linux/glibc they do not.

RETURN VALUE
       On success, the PID of the child process is returned in the parent,
       and  0 is returned in the child.  On failure, -1 is returned in the
       parent, no child process is created, and  errno  is  set  appropri‐
       ately.

ERRORS
       EAGAIN A  system-imposed limit on the number of threads was encoun‐
              tered.  There are a number of limits that may  trigger  this
              error:

              *  the  RLIMIT_NPROC  soft  resource  limit  (set  via setr‐
                 limit(2)), which  limits  the  number  of  processes  and
                 threads for a real user ID, was reached;

              *  the kernel's system-wide limit on the number of processes
                 and threads,  /proc/sys/kernel/threads-max,  was  reached
                 (see proc(5));

              *  the maximum number of PIDs, /proc/sys/kernel/pid_max, was
                 reached (see proc(5)); or

              *  the PID limit (pids.max) imposed by the  cgroup  "process
                 number" (PIDs) controller was reached.

       EAGAIN The  caller is operating under the SCHED_DEADLINE scheduling
              policy and does not have the reset-on-fork  flag  set.   See
              sched(7).

       ENOMEM fork()  failed  to  allocate the necessary kernel structures
              because memory is tight.

       ENOMEM An attempt was made to create a child process in a PID name‐
              space  whose  "init"  process has terminated.  See pid_name‐
              spaces(7).

       ENOSYS fork() is not supported on this platform (for example, hard‐
              ware without a Memory-Management Unit).

       ERESTARTNOINTR (since Linux 2.6.17)
              System  call  was  interrupted  by  a  signal  and  will  be
              restarted.  (This can be seen only during a trace.)

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

NOTES
       Under Linux, fork() is implemented using  copy-on-write  pages,  so
       the  only penalty that it incurs is the time and memory required to
       duplicate the parent's page tables, and to  create  a  unique  task
       structure for the child.

   C library/kernel differences
       Since  version 2.3.3, rather than invoking the kernel's fork() sys‐
       tem call, the glibc fork() wrapper that is provided as part of  the
       NPTL threading implementation invokes clone(2) with flags that pro‐
       vide the same effect as the traditional system call.   (A  call  to
       fork() is equivalent to a call to clone(2) specifying flags as just
       SIGCHLD.)  The glibc wrapper invokes any fork  handlers  that  have
       been established using pthread_atfork(3).

EXAMPLES
       See pipe(2) and wait(2).

SEE ALSO
       clone(2),  execve(2),  exit(2), setrlimit(2), unshare(2), vfork(2),
       wait(2),  daemon(3),  pthread_atfork(3),  capabilities(7),  creden‐
       tials(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-06-09                         FORK(2)
MALLOC(3)                Linux Programmer's Manual               MALLOC(3)

NAME
       malloc, free, calloc, realloc, reallocarray - allocate and free dy‐
       namic memory

SYNOPSIS
       #include <stdlib.h>

       void *malloc(size_t size);
       void free(void *ptr);
       void *calloc(size_t nmemb, size_t size);
       void *realloc(void *ptr, size_t size);
       void *reallocarray(void *ptr, size_t nmemb, size_t size);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       reallocarray():
           Since glibc 2.29:
               _DEFAULT_SOURCE
           Glibc 2.28 and earlier:
               _GNU_SOURCE

DESCRIPTION
       The malloc() function allocates size bytes and returns a pointer to
       the  allocated  memory.  The memory is not initialized.  If size is
       0, then malloc() returns either NULL, or  a  unique  pointer  value
       that can later be successfully passed to free().

       The free() function frees the memory space pointed to by ptr, which
       must have been returned by a previous call to  malloc(),  calloc(),
       or  realloc().   Otherwise, or if free(ptr) has already been called
       before, undefined behavior occurs.  If ptr is NULL, no operation is
       performed.

       The  calloc()  function allocates memory for an array of nmemb ele‐
       ments of size bytes each and returns a  pointer  to  the  allocated
       memory.   The  memory  is set to zero.  If nmemb or size is 0, then
       calloc() returns either NULL, or a unique pointer  value  that  can
       later  be  successfully passed to free().  If the multiplication of
       nmemb and size would result in integer overflow, then calloc()  re‐
       turns  an error.  By contrast, an integer overflow would not be de‐
       tected in the following call to malloc(), with the result  that  an
       incorrectly sized block of memory would be allocated:

           malloc(nmemb * size);

       The realloc() function changes the size of the memory block pointed
       to by ptr to size bytes.  The contents will  be  unchanged  in  the
       range from the start of the region up to the minimum of the old and
       new sizes.  If the new size is larger than the old size, the  added
       memory  will  not be initialized.  If ptr is NULL, then the call is
       equivalent to malloc(size), for all values  of  size;  if  size  is
       equal  to zero, and ptr is not NULL, then the call is equivalent to
       free(ptr).  Unless ptr is NULL, it must have been  returned  by  an
       earlier  call  to  malloc(),  calloc(),  or realloc().  If the area
       pointed to was moved, a free(ptr) is done.

       The reallocarray() function changes the size of  the  memory  block
       pointed  to  by  ptr  to be large enough for an array of nmemb ele‐
       ments, each of which is size bytes.  It is equivalent to the call

               realloc(ptr, nmemb * size);

       However, unlike that realloc() call, reallocarray() fails safely in
       the case where the multiplication would overflow.  If such an over‐
       flow occurs, reallocarray() returns NULL, sets errno to ENOMEM, and
       leaves the original block of memory unchanged.

RETURN VALUE
       The  malloc()  and calloc() functions return a pointer to the allo‐
       cated memory, which is suitably aligned for any built-in type.   On
       error, these functions return NULL.  NULL may also be returned by a
       successful call to malloc() with a size of zero, or by a successful
       call to calloc() with nmemb or size equal to zero.

       The free() function returns no value.

       The  realloc()  function  returns  a pointer to the newly allocated
       memory, which is suitably aligned for any built-in type, or NULL if
       the request failed.  The returned pointer may be the same as ptr if
       the allocation was not moved (e.g., there was room  to  expand  the
       allocation  in-place),  or different from ptr if the allocation was
       moved to a new address.  If size was equal to 0, either NULL  or  a
       pointer  suitable to be passed to free() is returned.  If realloc()
       fails, the original block is left untouched; it  is  not  freed  or
       moved.

       On  success,  the  reallocarray() function returns a pointer to the
       newly allocated memory.  On failure, it returns NULL and the origi‐
       nal block of memory is left untouched.

ERRORS
       calloc(), malloc(), realloc(), and reallocarray() can fail with the
       following error:

       ENOMEM Out of memory.  Possibly, the application hit the  RLIMIT_AS
              or RLIMIT_DATA limit described in getrlimit(2).

VERSIONS
       reallocarray() first appeared in glibc in version 2.26.

ATTRIBUTES
       For  an  explanation  of  the  terms  used in this section, see at‐
       tributes(7).

       ┌─────────────────────┬───────────────┬─────────┐
       │Interface            │ Attribute     │ Value   │
       ├─────────────────────┼───────────────┼─────────┤
       │malloc(), free(),    │ Thread safety │ MT-Safe │
       │calloc(), realloc()  │               │         │
       └─────────────────────┴───────────────┴─────────┘
CONFORMING TO
       malloc(), free(), calloc(), realloc(): POSIX.1-2001,  POSIX.1-2008,
       C89, C99.

       reallocarray()  is  a  nonstandard extension that first appeared in
       OpenBSD 5.6 and FreeBSD 11.0.

NOTES
       By default, Linux follows an optimistic memory allocation strategy.
       This  means that when malloc() returns non-NULL there is no guaran‐
       tee that the memory really is available.  In case it turns out that
       the  system  is out of memory, one or more processes will be killed
       by the OOM killer.  For more information, see  the  description  of
       /proc/sys/vm/overcommit_memory and /proc/sys/vm/oom_adj in proc(5),
       and the Linux kernel  source  file  Documentation/vm/overcommit-ac‐
       counting.rst.

       Normally,  malloc() allocates memory from the heap, and adjusts the
       size of the heap  as  required,  using  sbrk(2).   When  allocating
       blocks  of  memory larger than MMAP_THRESHOLD bytes, the glibc mal‐
       loc() implementation allocates the memory as  a  private  anonymous
       mapping using mmap(2).  MMAP_THRESHOLD is 128 kB by default, but is
       adjustable using mallopt(3).  Prior to Linux 4.7  allocations  per‐
       formed  using  mmap(2)  were unaffected by the RLIMIT_DATA resource
       limit; since Linux 4.7, this limit is also enforced for allocations
       performed using mmap(2).

       To avoid corruption in multithreaded applications, mutexes are used
       internally to protect the  memory-management  data  structures  em‐
       ployed by these functions.  In a multithreaded application in which
       threads simultaneously allocate and free  memory,  there  could  be
       contention for these mutexes.  To scalably handle memory allocation
       in multithreaded applications, glibc creates additional memory  al‐
       location  arenas  if mutex contention is detected.  Each arena is a
       large region of memory that is internally allocated by  the  system
       (using brk(2) or mmap(2)), and managed with its own mutexes.

       SUSv2  requires  malloc(),  calloc(), and realloc() to set errno to
       ENOMEM upon failure.  Glibc assumes that  this  is  done  (and  the
       glibc  versions  of  these  routines do this); if you use a private
       malloc implementation that does not set errno, then certain library
       routines may fail without having a reason in errno.

       Crashes  in malloc(), calloc(), realloc(), or free() are almost al‐
       ways related to heap corruption, such as overflowing  an  allocated
       chunk or freeing the same pointer twice.

       The  malloc()  implementation is tunable via environment variables;
       see mallopt(3) for details.

SEE ALSO
       valgrind(1), brk(2), mmap(2), alloca(3), malloc_get_state(3),
       malloc_info(3), malloc_trim(3), malloc_usable_size(3), mallopt(3),
       mcheck(3), mtrace(3), posix_memalign(3)

       For details of the GNU C library implementation, see
       ⟨https://sourceware.org/glibc/wiki/MallocInternals⟩.

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the latest version of this page, can be found at
       https://www.kernel.org/doc/man-pages/.

GNU                             2020-06-09                       MALLOC(3)
GETCWD(3)                Linux Programmer's Manual               GETCWD(3)

NAME
       getcwd, getwd, get_current_dir_name - get current working directory

SYNOPSIS
       #include <unistd.h>

       char *getcwd(char *buf, size_t size);

       char *getwd(char *buf);

       char *get_current_dir_name(void);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       get_current_dir_name():
              _GNU_SOURCE

       getwd():
           Since glibc 2.12:
               (_XOPEN_SOURCE >= 500) && ! (_POSIX_C_SOURCE >= 200809L)
                   || /* Glibc since 2.19: */ _DEFAULT_SOURCE
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE
           Before glibc 2.12:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500

DESCRIPTION
       These functions return a null-terminated string containing an abso‐
       lute pathname that is the current working directory of the  calling
       process.   The  pathname is returned as the function result and via
       the argument buf, if present.

       The getcwd() function copies an absolute pathname  of  the  current
       working  directory  to  the  array  pointed  to by buf, which is of
       length size.

       If the length of the absolute pathname of the current  working  di‐
       rectory,  including  the terminating null byte, exceeds size bytes,
       NULL is returned, and errno is set to ERANGE; an application should
       check for this error, and allocate a larger buffer if necessary.

       As  an extension to the POSIX.1-2001 standard, glibc's getcwd() al‐
       locates the buffer dynamically using malloc(3) if buf is NULL.   In
       this  case, the allocated buffer has the length size unless size is
       zero, when buf is allocated as big as necessary.  The caller should
       free(3) the returned buffer.

       get_current_dir_name()  will  malloc(3) an array big enough to hold
       the absolute pathname of the current working directory.  If the en‐
       vironment  variable PWD is set, and its value is correct, then that
       value will be returned.  The caller  should  free(3)  the  returned
       buffer.

       getwd()  does not malloc(3) any memory.  The buf argument should be
       a pointer to an array at least PATH_MAX bytes long.  If the  length
       of  the absolute pathname of the current working directory, includ‐
       ing the terminating null byte, exceeds PATH_MAX bytes, NULL is  re‐
       turned,  and errno is set to ENAMETOOLONG.  (Note that on some sys‐
       tems, PATH_MAX may not be a compile-time constant; furthermore, its
       value  may  depend on the filesystem, see pathconf(3).)  For porta‐
       bility and security reasons, use of getwd() is deprecated.

RETURN VALUE
       On success, these functions return a pointer to a string containing
       the  pathname  of  the  current  working directory.  In the case of
       getcwd() and getwd() this is the same value as buf.

       On failure, these functions return NULL, and errno is set to  indi‐
       cate  the  error.   The contents of the array pointed to by buf are
       undefined on error.

ERRORS
       EACCES Permission to read or search a component of the filename was
              denied.

       EFAULT buf points to a bad address.

       EINVAL The size argument is zero and buf is not a null pointer.

       EINVAL getwd(): buf is NULL.

       ENAMETOOLONG
              getwd():  The  size of the null-terminated absolute pathname
              string exceeds PATH_MAX bytes.

       ENOENT The current working directory has been unlinked.

       ENOMEM Out of memory.

       ERANGE The size argument is less than the length  of  the  absolute
              pathname of the working directory, including the terminating
              null byte.  You need to allocate  a  bigger  array  and  try
              again.

ATTRIBUTES
       For  an  explanation  of  the  terms  used in this section, see at‐
       tributes(7).

       ┌───────────────────────┬───────────────┬─────────────┐
       │Interface              │ Attribute     │ Value       │
       ├───────────────────────┼───────────────┼─────────────┤
       │getcwd(), getwd()      │ Thread safety │ MT-Safe     │
       ├───────────────────────┼───────────────┼─────────────┤
       │get_current_dir_name() │ Thread safety │ MT-Safe env │
       └───────────────────────┴───────────────┴─────────────┘
CONFORMING TO
       getcwd() conforms to POSIX.1-2001.  Note however that  POSIX.1-2001
       leaves the behavior of getcwd() unspecified if buf is NULL.

       getwd()   is   present   in   POSIX.1-2001,   but   marked  LEGACY.
       POSIX.1-2008 removes the specification of  getwd().   Use  getcwd()
       instead.  POSIX.1-2001 does not define any errors for getwd().

       get_current_dir_name() is a GNU extension.

NOTES
       Under  Linux,  these functions make use of the getcwd() system call
       (available since Linux 2.1.92).  On older systems they would  query
       /proc/self/cwd.   If both system call and proc filesystem are miss‐
       ing, a generic implementation is called.  Only  in  that  case  can
       these calls fail under Linux with EACCES.

       These  functions are often used to save the location of the current
       working directory for the purpose of returning to it later.   Open‐
       ing  the current directory (".") and calling fchdir(2) to return is
       usually a faster and more reliable  alternative  when  sufficiently
       many  file descriptors are available, especially on platforms other
       than Linux.

   C library/kernel differences
       On Linux, the kernel provides a getcwd()  system  call,  which  the
       functions  described in this page will use if possible.  The system
       call takes the same arguments as the library function of  the  same
       name,  but is limited to returning at most PATH_MAX bytes.  (Before
       Linux 3.12, the limit on the size of the returned pathname was  the
       system  page  size.  On many architectures, PATH_MAX and the system
       page size are both 4096 bytes,  but  a  few  architectures  have  a
       larger  page  size.)   If the length of the pathname of the current
       working directory exceeds this limit, then the  system  call  fails
       with  the  error ENAMETOOLONG.  In this case, the library functions
       fall back to a (slower) alternative implementation that returns the
       full pathname.

       Following  a  change  in Linux 2.6.36, the pathname returned by the
       getcwd() system call will be prefixed with  the  string  "(unreach‐
       able)"  if the current directory is not below the root directory of
       the current process (e.g., because the process set a new filesystem
       root  using  chroot(2)  without changing its current directory into
       the new root).  Such behavior can also be caused by an unprivileged
       user  by  changing  the  current directory into another mount name‐
       space.  When dealing with pathname from untrusted sources,  callers
       of  the  functions  described in this page should consider checking
       whether the returned pathname starts with '/' or '(' to avoid  mis‐
       interpreting an unreachable path as a relative pathname.

BUGS
       Since  the  Linux  2.6.36  change that added "(unreachable)" in the
       circumstances described above, the glibc implementation of getcwd()
       has  failed  to  conform  to POSIX and returned a relative pathname
       when the API contract requires an absolute  pathname.   With  glibc
       2.27  onwards this is corrected; calling getcwd() from such a path‐
       name will now result in failure with ENOENT.

SEE ALSO
       pwd(1), chdir(2), fchdir(2), open(2), unlink(2), free(3), malloc(3)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

GNU                             2018-04-30                       GETCWD(3)
GETLINE(3)               Linux Programmer's Manual              GETLINE(3)

NAME
       getline, getdelim - delimited string input

SYNOPSIS
       #include <stdio.h>

       ssize_t getline(char **lineptr, size_t *n, FILE *stream);

       ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getline(), getdelim():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _GNU_SOURCE

DESCRIPTION
       getline()  reads an entire line from stream, storing the address of
       the buffer containing the text into *lineptr.  The buffer is  null-
       terminated and includes the newline character, if one was found.

       If  *lineptr  is  set to NULL and *n is set 0 before the call, then
       getline() will allocate a buffer for storing the line.  This buffer
       should be freed by the user program even if getline() failed.

       Alternatively,  before  calling  getline(),  *lineptr can contain a
       pointer to a malloc(3)-allocated buffer *n bytes in size.   If  the
       buffer  is  not large enough to hold the line, getline() resizes it
       with realloc(3), updating *lineptr and *n as necessary.

       In either case, on a successful call, *lineptr and *n will  be  up‐
       dated  to  reflect  the  buffer  address and allocated size respec‐
       tively.

       getdelim() works like getline(), except that a line delimiter other
       than  newline  can be specified as the delimiter argument.  As with
       getline(), a delimiter character  is  not  added  if  one  was  not
       present in the input before end of file was reached.

RETURN VALUE
       On  success,  getline() and getdelim() return the number of charac‐
       ters read, including the delimiter character, but not including the
       terminating null byte ('\0').  This value can be used to handle em‐
       bedded null bytes in the line read.

       Both functions return -1 on failure to read a line (including  end-
       of-file  condition).  In the event of an error, errno is set to in‐
       dicate the cause.

ERRORS
       EINVAL Bad arguments (n or  lineptr  is  NULL,  or  stream  is  not
              valid).

       ENOMEM Allocation or reallocation of the line buffer failed.

ATTRIBUTES
       For  an  explanation  of  the  terms  used in this section, see at‐
       tributes(7).

       ┌──────────────────────┬───────────────┬─────────┐
       │Interface             │ Attribute     │ Value   │
       ├──────────────────────┼───────────────┼─────────┤
       │getline(), getdelim() │ Thread safety │ MT-Safe │
       └──────────────────────┴───────────────┴─────────┘

CONFORMING TO
       Both getline() and getdelim() were originally GNU extensions.  They
       were standardized in POSIX.1-2008.

EXAMPLES
       #define _GNU_SOURCE
       #include <stdio.h>
       #include <stdlib.h>

       int
       main(int argc, char *argv[])
       {
           FILE *stream;
           char *line = NULL;
           size_t len = 0;
           ssize_t nread;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <file>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           stream = fopen(argv[1], "r");
           if (stream == NULL) {
               perror("fopen");
               exit(EXIT_FAILURE);
           }

           while ((nread = getline(&line, &len, stream)) != -1) {
               printf("Retrieved line of length %zd:\n", nread);
               fwrite(line, nread, 1, stdout);
           }

           free(line);
           fclose(stream);
           exit(EXIT_SUCCESS);
       }

SEE ALSO
       read(2), fgets(3), fopen(3), fread(3), scanf(3)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

GNU                             2020-11-01                      GETLINE(3)
GETPID(2)                Linux Programmer's Manual               GETPID(2)

NAME
       getpid, getppid - get process identification

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       pid_t getpid(void);
       pid_t getppid(void);

DESCRIPTION
       getpid()  returns  the  process  ID  (PID)  of the calling process.
       (This is often used by  routines  that  generate  unique  temporary
       filenames.)

       getppid()  returns  the  process  ID  of  the parent of the calling
       process.  This will be either the ID of the  process  that  created
       this  process  using fork(), or, if that process has already termi‐
       nated, the ID of the process to which this process has been  repar‐
       ented  (either  init(1)  or  a  "subreaper" process defined via the
       prctl(2) PR_SET_CHILD_SUBREAPER operation).

ERRORS
       These functions are always successful.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4.

NOTES
       If the caller's  parent  is  in  a  different  PID  namespace  (see
       pid_namespaces(7)), getppid() returns 0.

       From  a  kernel perspective, the PID (which is shared by all of the
       threads in a multithreaded process) is sometimes also known as  the
       thread  group  ID (TGID).  This contrasts with the kernel thread ID
       (TID), which is unique for each thread.  For further  details,  see
       gettid(2) and the discussion of the CLONE_THREAD flag in clone(2).

   C library/kernel differences
       From  glibc  version  2.3.4  up  to and including version 2.24, the
       glibc wrapper function for getpid() cached PIDs, with the  goal  of
       avoiding  additional system calls when a process calls getpid() re‐
       peatedly.  Normally this caching was invisible, but its correct op‐
       eration  relied  on  support  in the wrapper functions for fork(2),
       vfork(2), and clone(2): if an application bypassed the glibc  wrap‐
       pers  for  these  system  calls by using syscall(2), then a call to
       getpid() in the child would return the wrong value (to be  precise:
       it would return the PID of the parent process).  In addition, there
       were cases where getpid() could return the wrong  value  even  when
       invoking  clone(2)  via the glibc wrapper function.  (For a discus‐
       sion of one such case, see BUGS  in  clone(2).)   Furthermore,  the
       complexity  of  the  caching code had been the source of a few bugs
       within glibc over the years.

       Because of the aforementioned problems, since glibc  version  2.25,
       the  PID  cache is removed: calls to getpid() always invoke the ac‐
       tual system call, rather than returning a cached value.

       On Alpha, instead of a pair of getpid() and getppid() system calls,
       a single getxpid() system call is provided, which returns a pair of
       PID and parent PID.  The glibc getpid() and getppid() wrapper func‐
       tions transparently deal with this.  See syscall(2) for details re‐
       garding register mapping.

SEE ALSO
       clone(2), fork(2), gettid(2), kill(2), exec(3),  mkstemp(3),  temp‐
       nam(3), tmpfile(3), tmpnam(3), credentials(7), pid_namespaces(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-11-01                       GETPID(2)
ISATTY(3)                Linux Programmer's Manual               ISATTY(3)

NAME
       isatty - test whether a file descriptor refers to a terminal

SYNOPSIS
       #include <unistd.h>

       int isatty(int fd);

DESCRIPTION
       The  isatty()  function tests whether fd is an open file descriptor
       referring to a terminal.

RETURN VALUE
       isatty() returns 1 if fd is an open file descriptor referring to  a
       terminal; otherwise 0 is returned, and errno is set to indicate the
       error.

ERRORS
       EBADF  fd is not a valid file descriptor.

       ENOTTY fd refers to a file other than a terminal.   On  some  older
              kernels, some types of files resulted in the error EINVAL in
              this case (which is a violation of  POSIX,  which  specifies
              the error ENOTTY).

ATTRIBUTES
       For  an  explanation  of  the  terms  used in this section, see at‐
       tributes(7).

       ┌──────────┬───────────────┬─────────┐
       │Interface │ Attribute     │ Value   │
       ├──────────┼───────────────┼─────────┤
       │isatty()  │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘
CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

SEE ALSO
       fstat(2), ttyname(3)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2019-03-06                       ISATTY(3)
KILL(2)                  Linux Programmer's Manual                 KILL(2)

NAME
       kill - send signal to a process

SYNOPSIS
       #include <sys/types.h>
       #include <signal.h>

       int kill(pid_t pid, int sig);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       kill(): _POSIX_C_SOURCE

DESCRIPTION
       The  kill()  system  call  can  be  used  to send any signal to any
       process group or process.

       If pid is positive, then signal sig is sent to the process with the
       ID specified by pid.

       If  pid  equals 0, then sig is sent to every process in the process
       group of the calling process.

       If pid equals -1, then sig is sent to every process for  which  the
       calling  process has permission to send signals, except for process
       1 (init), but see below.

       If pid is less than -1, then sig is sent to every  process  in  the
       process group whose ID is -pid.

       If  sig  is 0, then no signal is sent, but existence and permission
       checks are still performed; this can be used to check for the exis‐
       tence  of  a process ID or process group ID that the caller is per‐
       mitted to signal.

       For a process to have permission to send a signal, it  must  either
       be  privileged  (under  Linux:  have the CAP_KILL capability in the
       user namespace of the target process), or  the  real  or  effective
       user  ID  of  the sending process must equal the real or saved set-
       user-ID of the target process.  In the case of SIGCONT, it suffices
       when  the  sending  and receiving processes belong to the same ses‐
       sion.  (Historically, the rules were different; see NOTES.)

RETURN VALUE
       On success (at least one signal was sent), zero  is  returned.   On
       error, -1 is returned, and errno is set appropriately.

ERRORS
       EINVAL An invalid signal was specified.

       EPERM  The  calling  process  does  not have permission to send the
              signal to any of the target processes.

       ESRCH  The target process or process group does  not  exist.   Note
              that  an  existing process might be a zombie, a process that
              has terminated execution, but has  not  yet  been  wait(2)ed
              for.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

NOTES
       The  only  signals  that  can  be  sent  to  process ID 1, the init
       process, are those for which init has explicitly  installed  signal
       handlers.   This  is  done to assure the system is not brought down
       accidentally.

       POSIX.1 requires that kill(-1,sig) send sig to all  processes  that
       the  calling  process may send signals to, except possibly for some
       implementation-defined system processes.  Linux allows a process to
       signal  itself,  but on Linux the call kill(-1,sig) does not signal
       the calling process.

       POSIX.1 requires that if a process sends a signal  to  itself,  and
       the  sending  thread does not have the signal blocked, and no other
       thread has it unblocked or is waiting  for  it  in  sigwait(3),  at
       least  one unblocked signal must be delivered to the sending thread
       before the kill() returns.

   Linux notes
       Across different kernel  versions,  Linux  has  enforced  different
       rules  for  the permissions required for an unprivileged process to
       send a signal to another process.  In kernels 1.0 to 1.2.2, a  sig‐
       nal  could  be  sent if the effective user ID of the sender matched
       effective user ID of the target, or the real user ID of the  sender
       matched  the  real  user ID of the target.  From kernel 1.2.3 until
       1.3.77, a signal could be sent if the  effective  user  ID  of  the
       sender  matched either the real or effective user ID of the target.
       The current rules, which conform to POSIX.1, were adopted in kernel
       1.3.78.

BUGS
       In  2.6  kernels  up  to  and including 2.6.7, there was a bug that
       meant that when sending signals to a process group,  kill()  failed
       with  the error EPERM if the caller did not have permission to send
       the signal to any (rather than all) of the members of  the  process
       group.  Notwithstanding this error return, the signal was still de‐
       livered to all of the processes for which the caller had permission
       to signal.

SEE ALSO
       kill(1),   _exit(2),   pidfd_send_signal(2),  signal(2),  tkill(2),
       exit(3), killpg(3), sigqueue(3),  capabilities(7),  credentials(7),
       signal(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2019-10-10                         KILL(2)
MALLOC(3)                Linux Programmer's Manual               MALLOC(3)

NAME
       malloc, free, calloc, realloc, reallocarray - allocate and free dy‐
       namic memory

SYNOPSIS
       #include <stdlib.h>

       void *malloc(size_t size);
       void free(void *ptr);
       void *calloc(size_t nmemb, size_t size);
       void *realloc(void *ptr, size_t size);
       void *reallocarray(void *ptr, size_t nmemb, size_t size);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       reallocarray():
           Since glibc 2.29:
               _DEFAULT_SOURCE
           Glibc 2.28 and earlier:
               _GNU_SOURCE

DESCRIPTION
       The malloc() function allocates size bytes and returns a pointer to
       the  allocated  memory.  The memory is not initialized.  If size is
       0, then malloc() returns either NULL, or  a  unique  pointer  value
       that can later be successfully passed to free().

       The free() function frees the memory space pointed to by ptr, which
       must have been returned by a previous call to  malloc(),  calloc(),
       or  realloc().   Otherwise, or if free(ptr) has already been called
       before, undefined behavior occurs.  If ptr is NULL, no operation is
       performed.

       The  calloc()  function allocates memory for an array of nmemb ele‐
       ments of size bytes each and returns a  pointer  to  the  allocated
       memory.   The  memory  is set to zero.  If nmemb or size is 0, then
       calloc() returns either NULL, or a unique pointer  value  that  can
       later  be  successfully passed to free().  If the multiplication of
       nmemb and size would result in integer overflow, then calloc()  re‐
       turns  an error.  By contrast, an integer overflow would not be de‐
       tected in the following call to malloc(), with the result  that  an
       incorrectly sized block of memory would be allocated:

           malloc(nmemb * size);

       The realloc() function changes the size of the memory block pointed
       to by ptr to size bytes.  The contents will  be  unchanged  in  the
       range from the start of the region up to the minimum of the old and
       new sizes.  If the new size is larger than the old size, the  added
       memory  will  not be initialized.  If ptr is NULL, then the call is
       equivalent to malloc(size), for all values  of  size;  if  size  is
       equal  to zero, and ptr is not NULL, then the call is equivalent to
       free(ptr).  Unless ptr is NULL, it must have been  returned  by  an
       earlier  call  to  malloc(),  calloc(),  or realloc().  If the area
       pointed to was moved, a free(ptr) is done.

       The reallocarray() function changes the size of  the  memory  block
       pointed  to  by  ptr  to be large enough for an array of nmemb ele‐
       ments, each of which is size bytes.  It is equivalent to the call

               realloc(ptr, nmemb * size);

       However, unlike that realloc() call, reallocarray() fails safely in
       the case where the multiplication would overflow.  If such an over‐
       flow occurs, reallocarray() returns NULL, sets errno to ENOMEM, and
       leaves the original block of memory unchanged.

RETURN VALUE
       The  malloc()  and calloc() functions return a pointer to the allo‐
       cated memory, which is suitably aligned for any built-in type.   On
       error, these functions return NULL.  NULL may also be returned by a
       successful call to malloc() with a size of zero, or by a successful
       call to calloc() with nmemb or size equal to zero.

       The free() function returns no value.

       The  realloc()  function  returns  a pointer to the newly allocated
       memory, which is suitably aligned for any built-in type, or NULL if
       the request failed.  The returned pointer may be the same as ptr if
       the allocation was not moved (e.g., there was room  to  expand  the
       allocation  in-place),  or different from ptr if the allocation was
       moved to a new address.  If size was equal to 0, either NULL  or  a
       pointer  suitable to be passed to free() is returned.  If realloc()
       fails, the original block is left untouched; it  is  not  freed  or
       moved.

       On  success,  the  reallocarray() function returns a pointer to the
       newly allocated memory.  On failure, it returns NULL and the origi‐
       nal block of memory is left untouched.

ERRORS
       calloc(), malloc(), realloc(), and reallocarray() can fail with the
       following error:

       ENOMEM Out of memory.  Possibly, the application hit the  RLIMIT_AS
              or RLIMIT_DATA limit described in getrlimit(2).

VERSIONS
       reallocarray() first appeared in glibc in version 2.26.

ATTRIBUTES
       For  an  explanation  of  the  terms  used in this section, see at‐
       tributes(7).

       ┌─────────────────────┬───────────────┬─────────┐
       │Interface            │ Attribute     │ Value   │
       ├─────────────────────┼───────────────┼─────────┤
       │malloc(), free(),    │ Thread safety │ MT-Safe │
       │calloc(), realloc()  │               │         │
       └─────────────────────┴───────────────┴─────────┘
CONFORMING TO
       malloc(), free(), calloc(), realloc(): POSIX.1-2001,  POSIX.1-2008,
       C89, C99.

       reallocarray()  is  a  nonstandard extension that first appeared in
       OpenBSD 5.6 and FreeBSD 11.0.

NOTES
       By default, Linux follows an optimistic memory allocation strategy.
       This  means that when malloc() returns non-NULL there is no guaran‐
       tee that the memory really is available.  In case it turns out that
       the  system  is out of memory, one or more processes will be killed
       by the OOM killer.  For more information, see  the  description  of
       /proc/sys/vm/overcommit_memory and /proc/sys/vm/oom_adj in proc(5),
       and the Linux kernel  source  file  Documentation/vm/overcommit-ac‐
       counting.rst.

       Normally,  malloc() allocates memory from the heap, and adjusts the
       size of the heap  as  required,  using  sbrk(2).   When  allocating
       blocks  of  memory larger than MMAP_THRESHOLD bytes, the glibc mal‐
       loc() implementation allocates the memory as  a  private  anonymous
       mapping using mmap(2).  MMAP_THRESHOLD is 128 kB by default, but is
       adjustable using mallopt(3).  Prior to Linux 4.7  allocations  per‐
       formed  using  mmap(2)  were unaffected by the RLIMIT_DATA resource
       limit; since Linux 4.7, this limit is also enforced for allocations
       performed using mmap(2).

       To avoid corruption in multithreaded applications, mutexes are used
       internally to protect the  memory-management  data  structures  em‐
       ployed by these functions.  In a multithreaded application in which
       threads simultaneously allocate and free  memory,  there  could  be
       contention for these mutexes.  To scalably handle memory allocation
       in multithreaded applications, glibc creates additional memory  al‐
       location  arenas  if mutex contention is detected.  Each arena is a
       large region of memory that is internally allocated by  the  system
       (using brk(2) or mmap(2)), and managed with its own mutexes.

       SUSv2  requires  malloc(),  calloc(), and realloc() to set errno to
       ENOMEM upon failure.  Glibc assumes that  this  is  done  (and  the
       glibc  versions  of  these  routines do this); if you use a private
       malloc implementation that does not set errno, then certain library
       routines may fail without having a reason in errno.

       Crashes  in malloc(), calloc(), realloc(), or free() are almost al‐
       ways related to heap corruption, such as overflowing  an  allocated
       chunk or freeing the same pointer twice.

       The  malloc()  implementation is tunable via environment variables;
       see mallopt(3) for details.

SEE ALSO
       valgrind(1), brk(2), mmap(2), alloca(3), malloc_get_state(3),
       malloc_info(3), malloc_trim(3), malloc_usable_size(3), mallopt(3),
       mcheck(3), mtrace(3), posix_memalign(3)

       For details of the GNU C library implementation, see
       ⟨https://sourceware.org/glibc/wiki/MallocInternals⟩.

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the latest version of this page, can be found at
       https://www.kernel.org/doc/man-pages/.

GNU                             2020-06-09                       MALLOC(3)
OPEN(2)                  Linux Programmer's Manual                 OPEN(2)

NAME
       open, openat, creat - open and possibly create a file

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

       int creat(const char *pathname, mode_t mode);

       int openat(int dirfd, const char *pathname, int flags);
       int openat(int dirfd, const char *pathname, int flags, mode_t mode);

       /* Documented separately, in openat2(2): */
       int openat2(int dirfd, const char *pathname,
                   const struct open_how *how, size_t size);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       openat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       The  open()  system  call opens the file specified by pathname.  If
       the specified file does not exist, it may optionally (if O_CREAT is
       specified in flags) be created by open().

       The  return value of open() is a file descriptor, a small, nonnega‐
       tive integer that is used  in  subsequent  system  calls  (read(2),
       write(2), lseek(2), fcntl(2), etc.) to refer to the open file.  The
       file descriptor returned by a successful call will be  the  lowest-
       numbered file descriptor not currently open for the process.

       By default, the new file descriptor is set to remain open across an
       execve(2) (i.e., the FD_CLOEXEC file descriptor flag  described  in
       fcntl(2)  is initially disabled); the O_CLOEXEC flag, described be‐
       low, can be used to change this default.  The file offset is set to
       the beginning of the file (see lseek(2)).

       A  call  to open() creates a new open file description, an entry in
       the system-wide table of open files.   The  open  file  description
       records  the  file offset and the file status flags (see below).  A
       file descriptor is a reference to an open  file  description;  this
       reference is unaffected if pathname is subsequently removed or mod‐
       ified to refer to a different file.  For further  details  on  open
       file descriptions, see NOTES.

       The  argument flags must include one of the following access modes:
       O_RDONLY, O_WRONLY, or O_RDWR.   These  request  opening  the  file
       read-only, write-only, or read/write, respectively.

       In addition, zero or more file creation flags and file status flags
       can  be  bitwise-or'd  in  flags.   The  file  creation  flags  are
       O_CLOEXEC,  O_CREAT,  O_DIRECTORY,  O_EXCL,  O_NOCTTY,  O_NOFOLLOW,
       O_TMPFILE, and O_TRUNC.  The file status flags are all of  the  re‐
       maining  flags  listed  below.   The  distinction between these two
       groups of flags is that the file creation flags affect  the  seman‐
       tics  of the open operation itself, while the file status flags af‐
       fect the semantics of subsequent I/O operations.  The  file  status
       flags  can  be retrieved and (in some cases) modified; see fcntl(2)
       for details.

       The full list of file creation flags and file status  flags  is  as
       follows:

       O_APPEND
              The  file  is  opened in append mode.  Before each write(2),
              the file offset is positioned at the end of the file, as  if
              with  lseek(2).  The modification of the file offset and the
              write operation are performed as a single atomic step.

              O_APPEND may lead to corrupted files on NFS  filesystems  if
              more  than one process appends data to a file at once.  This
              is because NFS does not support appending to a file, so  the
              client  kernel has to simulate it, which can't be done with‐
              out a race condition.

       O_ASYNC
              Enable signal-driven I/O: generate a signal  (SIGIO  by  de‐
              fault,  but  this can be changed via fcntl(2)) when input or
              output becomes possible on this file descriptor.  This  fea‐
              ture is available only for terminals, pseudoterminals, sock‐
              ets, and (since Linux 2.6) pipes and  FIFOs.   See  fcntl(2)
              for further details.  See also BUGS, below.

       O_CLOEXEC (since Linux 2.6.23)
              Enable  the  close-on-exec flag for the new file descriptor.
              Specifying this flag permits a program to  avoid  additional
              fcntl(2) F_SETFD operations to set the FD_CLOEXEC flag.

              Note  that  the use of this flag is essential in some multi‐
              threaded programs, because using a separate fcntl(2) F_SETFD
              operation  to  set  the  FD_CLOEXEC flag does not suffice to
              avoid race conditions where one thread opens a file descrip‐
              tor  and  attempts  to  set its close-on-exec flag using fc‐
              ntl(2) at the same time as another  thread  does  a  fork(2)
              plus  execve(2).   Depending  on the order of execution, the
              race may lead to the file descriptor returned by open()  be‐
              ing  unintentionally  leaked  to the program executed by the
              child process created by fork(2).  (This kind of race is  in
              principle  possible  for any system call that creates a file
              descriptor whose close-on-exec flag should be set, and vari‐
              ous  other  Linux  system calls provide an equivalent of the
              O_CLOEXEC flag to deal with this problem.)

       O_CREAT
              If pathname does not exist, create it as a regular file.

              The owner (user ID) of the new file is set to the  effective
              user ID of the process.

              The group ownership (group ID) of the new file is set either
              to the effective group ID of the process  (System  V  seman‐
              tics) or to the group ID of the parent directory (BSD seman‐
              tics).  On Linux, the behavior depends on whether  the  set-
              group-ID  mode  bit  is set on the parent directory: if that
              bit is set, then BSD semantics apply;  otherwise,  System  V
              semantics  apply.   For  some filesystems, the behavior also
              depends on the bsdgroups and sysvgroups  mount  options  de‐
              scribed in mount(8).

              The mode argument specifies the file mode bits to be applied
              when a new file is created.  If neither O_CREAT  nor  O_TMP‐
              FILE  is  specified  in flags, then mode is ignored (and can
              thus be specified as 0, or simply omitted).  The mode  argu‐
              ment  must  be supplied if O_CREAT or O_TMPFILE is specified
              in flags; if it is not supplied, some arbitrary  bytes  from
              the stack will be applied as the file mode.

              The effective mode is modified by the process's umask in the
              usual way: in the absence of a default ACL, the mode of  the
              created file is (mode & ~umask).

              Note  that mode applies only to future accesses of the newly
              created file; the open() call that creates a read-only  file
              may well return a read/write file descriptor.

              The following symbolic constants are provided for mode:

              S_IRWXU  00700  user  (file owner) has read, write, and exe‐
                       cute permission

              S_IRUSR  00400 user has read permission

              S_IWUSR  00200 user has write permission

              S_IXUSR  00100 user has execute permission

              S_IRWXG  00070 group has read, write, and execute permission

              S_IRGRP  00040 group has read permission

              S_IWGRP  00020 group has write permission

              S_IXGRP  00010 group has execute permission

              S_IRWXO  00007 others have read, write, and execute  permis‐
                       sion

              S_IROTH  00004 others have read permission

              S_IWOTH  00002 others have write permission

              S_IXOTH  00001 others have execute permission

              According  to  POSIX,  the effect when other bits are set in
              mode is unspecified.  On Linux, the following bits are  also
              honored in mode:

              S_ISUID  0004000 set-user-ID bit

              S_ISGID  0002000 set-group-ID bit (see inode(7)).

              S_ISVTX  0001000 sticky bit (see inode(7)).

       O_DIRECT (since Linux 2.4.10)
              Try  to  minimize  cache effects of the I/O to and from this
              file.  In general this will degrade performance, but  it  is
              useful  in  special situations, such as when applications do
              their own caching.  File I/O is done directly to/from  user-
              space buffers.  The O_DIRECT flag on its own makes an effort
              to transfer data synchronously, but does not give the  guar‐
              antees  of  the O_SYNC flag that data and necessary metadata
              are transferred.  To guarantee synchronous I/O, O_SYNC  must
              be  used  in addition to O_DIRECT.  See NOTES below for fur‐
              ther discussion.

              A semantically similar (but deprecated) interface for  block
              devices is described in raw(8).

       O_DIRECTORY
              If  pathname  is  not  a  directory, cause the open to fail.
              This flag was added in kernel version 2.1.126, to avoid  de‐
              nial-of-service  problems  if opendir(3) is called on a FIFO
              or tape device.

       O_DSYNC
              Write operations on the file will complete according to  the
              requirements of synchronized I/O data integrity completion.

              By  the  time write(2) (and similar) return, the output data
              has been transferred to the underlying hardware, along  with
              any  file  metadata  that would be required to retrieve that
              data (i.e., as though each write(2) was followed by  a  call
              to fdatasync(2)).  See NOTES below.

       O_EXCL Ensure  that  this  call  creates  the file: if this flag is
              specified in conjunction with O_CREAT, and pathname  already
              exists, then open() fails with the error EEXIST.

              When  these  two flags are specified, symbolic links are not
              followed: if pathname is a symbolic link, then open()  fails
              regardless of where the symbolic link points.

              In  general,  the  behavior  of O_EXCL is undefined if it is
              used without O_CREAT.  There is one exception: on Linux  2.6
              and  later,  O_EXCL  can be used without O_CREAT if pathname
              refers to a block device.  If the block device is in use  by
              the  system  (e.g.,  mounted),  open()  fails with the error
              EBUSY.

              On NFS, O_EXCL is supported only when using NFSv3  or  later
              on  kernel  2.6  or later.  In NFS environments where O_EXCL
              support is not provided, programs that rely on it  for  per‐
              forming locking tasks will contain a race condition.  Porta‐
              ble programs that want to perform atomic file locking  using
              a  lockfile,  and  need to avoid reliance on NFS support for
              O_EXCL, can create a unique  file  on  the  same  filesystem
              (e.g.,  incorporating  hostname and PID), and use link(2) to
              make a link to the lockfile.  If link(2) returns 0, the lock
              is successful.  Otherwise, use stat(2) on the unique file to
              check if its link count has increased to 2,  in  which  case
              the lock is also successful.

       O_LARGEFILE
              (LFS)  Allow  files  whose sizes cannot be represented in an
              off_t (but can be represented in an off64_t) to  be  opened.
              The  _LARGEFILE64_SOURCE  macro  must be defined (before in‐
              cluding any header files) in order to  obtain  this  defini‐
              tion.   Setting  the _FILE_OFFSET_BITS feature test macro to
              64 (rather than using O_LARGEFILE) is the  preferred  method
              of  accessing  large  files  on  32-bit  systems  (see  fea‐
              ture_test_macros(7)).

       O_NOATIME (since Linux 2.6.8)
              Do not update the file last access time (st_atime in the in‐
              ode) when the file is read(2).

              This  flag can be employed only if one of the following con‐
              ditions is true:

              *  The effective UID of the process matches the owner UID of
                 the file.

              *  The  calling process has the CAP_FOWNER capability in its
                 user namespace and the owner UID of the file has  a  map‐
                 ping in the namespace.

              This  flag  is  intended  for use by indexing or backup pro‐
              grams, where its use can significantly reduce the amount  of
              disk  activity.   This  flag  may  not  be  effective on all
              filesystems.  One example is NFS, where the server maintains
              the access time.

       O_NOCTTY
              If  pathname  refers to a terminal device—see tty(4)—it will
              not become the process's controlling terminal  even  if  the
              process does not have one.

       O_NOFOLLOW
              If  the trailing component (i.e., basename) of pathname is a
              symbolic link, then the open fails, with  the  error  ELOOP.
              Symbolic  links  in  earlier components of the pathname will
              still be followed.  (Note that the ELOOP error that can  oc‐
              cur in this case is indistinguishable from the case where an
              open fails because there are too many symbolic  links  found
              while  resolving  components in the prefix part of the path‐
              name.)

              This flag is a FreeBSD extension, which was added  to  Linux
              in  version  2.1.126, and has subsequently been standardized
              in POSIX.1-2008.

              See also O_PATH below.

       O_NONBLOCK or O_NDELAY
              When possible, the file is opened in nonblocking mode.  Nei‐
              ther  the  open()  nor  any subsequent I/O operations on the
              file descriptor which is returned  will  cause  the  calling
              process to wait.

              Note  that the setting of this flag has no effect on the op‐
              eration of poll(2), select(2), epoll(7), and similar,  since
              those  interfaces  merely  inform the caller about whether a
              file descriptor is "ready", meaning that  an  I/O  operation
              performed  on  the  file descriptor with the O_NONBLOCK flag
              clear would not block.

              Note that this flag has no  effect  for  regular  files  and
              block  devices; that is, I/O operations will (briefly) block
              when device activity  is  required,  regardless  of  whether
              O_NONBLOCK is set.  Since O_NONBLOCK semantics might eventu‐
              ally be implemented, applications  should  not  depend  upon
              blocking  behavior  when  specifying  this  flag for regular
              files and block devices.

              For the handling of FIFOs (named pipes), see  also  fifo(7).
              For  a discussion of the effect of O_NONBLOCK in conjunction
              with mandatory file locks and  with  file  leases,  see  fc‐
              ntl(2).

       O_PATH (since Linux 2.6.39)
              Obtain  a file descriptor that can be used for two purposes:
              to indicate a location in the filesystem tree and to perform
              operations  that  act  purely  at the file descriptor level.
              The file itself is not opened,  and  other  file  operations
              (e.g.,   read(2),  write(2),  fchmod(2),  fchown(2),  fgetx‐
              attr(2), ioctl(2), mmap(2)) fail with the error EBADF.

              The following operations can be performed on  the  resulting
              file descriptor:

              *  close(2).

              *  fchdir(2),  if  the file descriptor refers to a directory
                 (since Linux 3.5).

              *  fstat(2) (since Linux 3.6).

              *  fstatfs(2) (since Linux 3.12).

              *  Duplicating  the  file   descriptor   (dup(2),   fcntl(2)
                 F_DUPFD, etc.).

              *  Getting  and  setting  file  descriptor  flags  (fcntl(2)
                 F_GETFD and F_SETFD).

              *  Retrieving open file  status  flags  using  the  fcntl(2)
                 F_GETFL  operation:  the  returned flags will include the
                 bit O_PATH.

              *  Passing the file descriptor as the dirfd argument of ope‐
                 nat()  and the other "*at()" system calls.  This includes
                 linkat(2) with AT_EMPTY_PATH (or via procfs using AT_SYM‐
                 LINK_FOLLOW) even if the file is not a directory.

              *  Passing the file descriptor to another process via a UNIX
                 domain socket (see SCM_RIGHTS in unix(7)).

              When O_PATH is specified in  flags,  flag  bits  other  than
              O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW are ignored.

              Opening a file or directory with the O_PATH flag requires no
              permissions on the object itself (but does  require  execute
              permission  on the directories in the path prefix).  Depend‐
              ing on the subsequent operation, a check for  suitable  file
              permissions  may be performed (e.g., fchdir(2) requires exe‐
              cute permission on the directory referred to by its file de‐
              scriptor argument).  By contrast, obtaining a reference to a
              filesystem object by opening it with the O_RDONLY  flag  re‐
              quires  that  the caller have read permission on the object,
              even when the subsequent  operation  (e.g.,  fchdir(2),  fs‐
              tat(2)) does not require read permission on the object.

              If  pathname  is  a symbolic link and the O_NOFOLLOW flag is
              also specified, then the call returns a file descriptor  re‐
              ferring  to  the symbolic link.  This file descriptor can be
              used as the dirfd argument  in  calls  to  fchownat(2),  fs‐
              tatat(2),  linkat(2),  and readlinkat(2) with an empty path‐
              name to have the calls operate on the symbolic link.

              If pathname refers to an automount point that  has  not  yet
              been  triggered,  so  no  other filesystem is mounted on it,
              then the call returns a file descriptor referring to the au‐
              tomount  directory  without  triggering a mount.  fstatfs(2)
              can then be used to determine if it is, in fact, an  untrig‐
              gered automount point (.f_type == AUTOFS_SUPER_MAGIC).

              One use of O_PATH for regular files is to provide the equiv‐
              alent of POSIX.1's O_EXEC functionality.  This permits us to
              open  a  file  for  which we have execute permission but not
              read permission, and then  execute  that  file,  with  steps
              something like the following:

                  char buf[PATH_MAX];
                  fd = open("some_prog", O_PATH);
                  snprintf(buf, PATH_MAX, "/proc/self/fd/%d", fd);
                  execl(buf, "some_prog", (char *) NULL);

              An O_PATH file descriptor can also be passed as the argument
              of fexecve(3).

       O_SYNC Write operations on the file will complete according to  the
              requirements  of  synchronized I/O file integrity completion
              (by contrast with the synchronized I/O data  integrity  com‐
              pletion provided by O_DSYNC.)

              By  the  time write(2) (or similar) returns, the output data
              and associated file metadata have been  transferred  to  the
              underlying  hardware (i.e., as though each write(2) was fol‐
              lowed by a call to fsync(2)).  See NOTES below.

       O_TMPFILE (since Linux 3.11)
              Create an unnamed temporary regular file.  The pathname  ar‐
              gument  specifies a directory; an unnamed inode will be cre‐
              ated in that directory's filesystem.   Anything  written  to
              the  resulting file will be lost when the last file descrip‐
              tor is closed, unless the file is given a name.

              O_TMPFILE must be specified with one of O_RDWR  or  O_WRONLY
              and,  optionally,  O_EXCL.  If O_EXCL is not specified, then
              linkat(2) can be used to link the temporary  file  into  the
              filesystem, making it permanent, using code like the follow‐
              ing:

                  char path[PATH_MAX];
                  fd = open("/path/to/dir", O_TMPFILE | O_RDWR,
                                          S_IRUSR | S_IWUSR);

                  /* File I/O on 'fd'... */

                  linkat(fd, NULL, AT_FDCWD, "/path/for/file", AT_EMPTY_PATH);

                  /* If the caller doesn't have the CAP_DAC_READ_SEARCH
                     capability (needed to use AT_EMPTY_PATH with linkat(2)),
                     and there is a proc(5) filesystem mounted, then the
                     linkat(2) call above can be replaced with:

                  snprintf(path, PATH_MAX,  "/proc/self/fd/%d", fd);
                  linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file",
                                          AT_SYMLINK_FOLLOW);
                  */

              In this case, the open() mode argument determines  the  file
              permission mode, as with O_CREAT.

              Specifying  O_EXCL  in conjunction with O_TMPFILE prevents a
              temporary file from being linked into the filesystem in  the
              above manner.  (Note that the meaning of O_EXCL in this case
              is different from the meaning of O_EXCL otherwise.)

              There are two main use cases for O_TMPFILE:

              *  Improved tmpfile(3) functionality: race-free creation  of
                 temporary  files  that (1) are automatically deleted when
                 closed; (2) can never be reached via  any  pathname;  (3)
                 are  not  subject  to symlink attacks; and (4) do not re‐
                 quire the caller to devise unique names.

              *  Creating a file that is  initially  invisible,  which  is
                 then populated with data and adjusted to have appropriate
                 filesystem  attributes  (fchown(2),   fchmod(2),   fsetx‐
                 attr(2),  etc.)   before being atomically linked into the
                 filesystem in a fully formed state  (using  linkat(2)  as
                 described above).

              O_TMPFILE  requires  support  by  the underlying filesystem;
              only a subset of Linux filesystems provide that support.  In
              the  initial  implementation,  support  was  provided in the
              ext2, ext3, ext4, UDF, Minix, and shmem  filesystems.   Sup‐
              port  for  other  filesystems has subsequently been added as
              follows: XFS (Linux 3.15); Btrfs (Linux 3.16);  F2FS  (Linux
              3.16); and ubifs (Linux 4.9)

       O_TRUNC
              If the file already exists and is a regular file and the ac‐
              cess mode allows writing (i.e., is O_RDWR  or  O_WRONLY)  it
              will  be  truncated  to  length 0.  If the file is a FIFO or
              terminal device file, the O_TRUNC flag is  ignored.   Other‐
              wise, the effect of O_TRUNC is unspecified.

   creat()
       A  call to creat() is equivalent to calling open() with flags equal
       to O_CREAT|O_WRONLY|O_TRUNC.

   openat()
       The openat() system call  operates  in  exactly  the  same  way  as
       open(), except for the differences described here.

       If  the  pathname  given in pathname is relative, then it is inter‐
       preted relative to the directory referred to by the file descriptor
       dirfd (rather than relative to the current working directory of the
       calling process, as is done by open() for a relative pathname).

       If pathname is relative and dirfd is the  special  value  AT_FDCWD,
       then pathname is interpreted relative to the current working direc‐
       tory of the calling process (like open()).

       If pathname is absolute, then dirfd is ignored.

   openat2(2)
       The openat2(2) system call is an extension of  openat(),  and  pro‐
       vides  a  superset  of  the features of openat().  It is documented
       separately, in openat2(2).

RETURN VALUE
       open(), openat(), and creat() return the  new  file  descriptor  (a
       nonnegative  integer),  or  -1 if an error occurred (in which case,
       errno is set appropriately).

ERRORS
       open(), openat(), and creat() can fail with the following errors:

       EACCES The requested access to the file is not allowed,  or  search
              permission  is denied for one of the directories in the path
              prefix of pathname, or the file did not exist yet and  write
              access  to  the  parent directory is not allowed.  (See also
              path_resolution(7).)

       EACCES Where O_CREAT is  specified,  the  protected_fifos  or  pro‐
              tected_regular  sysctl  is  enabled, the file already exists
              and is a FIFO or regular file, the owner of the file is nei‐
              ther the current user nor the owner of the containing direc‐
              tory, and the containing directory is both world- or  group-
              writable  and  sticky.  For details, see the descriptions of
              /proc/sys/fs/protected_fifos and /proc/sys/fs/protected_reg‐
              ular in proc(5).

       EBUSY  O_EXCL was specified in flags and pathname refers to a block
              device that is in use by the system (e.g., it is mounted).

       EDQUOT Where O_CREAT is specified, the file does not exist, and the
              user's  quota of disk blocks or inodes on the filesystem has
              been exhausted.

       EEXIST pathname already exists and O_CREAT and O_EXCL were used.

       EFAULT pathname points outside your accessible address space.

       EFBIG  See EOVERFLOW.

       EINTR  While blocked waiting to complete an open of a  slow  device
              (e.g.,  a  FIFO; see fifo(7)), the call was interrupted by a
              signal handler; see signal(7).

       EINVAL The filesystem does not  support  the  O_DIRECT  flag.   See
              NOTES for more information.

       EINVAL Invalid value in flags.

       EINVAL O_TMPFILE  was  specified in flags, but neither O_WRONLY nor
              O_RDWR was specified.

       EINVAL O_CREAT was specified  in  flags  and  the  final  component
              ("basename") of the new file's pathname is invalid (e.g., it
              contains characters not permitted by the underlying filesys‐
              tem).

       EINVAL The  final  component  ("basename")  of  pathname is invalid
              (e.g., it contains characters not permitted by the  underly‐
              ing filesystem).

       EISDIR pathname  refers to a directory and the access requested in‐
              volved writing (that is, O_WRONLY or O_RDWR is set).

       EISDIR pathname refers to an existing directory, O_TMPFILE and  one
              of O_WRONLY or O_RDWR were specified in flags, but this ker‐
              nel version does not provide the O_TMPFILE functionality.

       ELOOP  Too many symbolic links were encountered in resolving  path‐
              name.

       ELOOP  pathname was a symbolic link, and flags specified O_NOFOLLOW
              but not O_PATH.

       EMFILE The per-process limit on the number of open file descriptors
              has  been  reached  (see the description of RLIMIT_NOFILE in
              getrlimit(2)).

       ENAMETOOLONG
              pathname was too long.

       ENFILE The system-wide limit on the total number of open files  has
              been reached.

       ENODEV pathname  refers to a device special file and no correspond‐
              ing device exists.  (This is a Linux  kernel  bug;  in  this
              situation ENXIO must be returned.)

       ENOENT O_CREAT is not set and the named file does not exist.

       ENOENT A  directory  component  in  pathname does not exist or is a
              dangling symbolic link.

       ENOENT pathname refers to a nonexistent  directory,  O_TMPFILE  and
              one  of O_WRONLY or O_RDWR were specified in flags, but this
              kernel version does not provide the O_TMPFILE functionality.

       ENOMEM The named file is a FIFO, but memory  for  the  FIFO  buffer
              can't be allocated because the per-user hard limit on memory
              allocation for pipes has been reached and the caller is  not
              privileged; see pipe(7).

       ENOMEM Insufficient kernel memory was available.

       ENOSPC pathname  was  to be created but the device containing path‐
              name has no room for the new file.

       ENOTDIR
              A component used as a directory in pathname is not, in fact,
              a  directory,  or O_DIRECTORY was specified and pathname was
              not a directory.

       ENXIO  O_NONBLOCK | O_WRONLY is set, the named file is a FIFO,  and
              no process has the FIFO open for reading.

       ENXIO  The  file  is a device special file and no corresponding de‐
              vice exists.

       ENXIO  The file is a UNIX domain socket.

       EOPNOTSUPP
              The filesystem containing pathname does not  support  O_TMP‐
              FILE.

       EOVERFLOW
              pathname  refers  to  a regular file that is too large to be
              opened.  The usual scenario here is that an application com‐
              piled  on  a  32-bit platform without -D_FILE_OFFSET_BITS=64
              tried to open a file whose size exceeds (1<<31)-1 bytes; see
              also  O_LARGEFILE  above.   This  is  the error specified by
              POSIX.1; in kernels before 2.6.24, Linux gave the error  EF‐
              BIG for this case.

       EPERM  The  O_NOATIME flag was specified, but the effective user ID
              of the caller did not match the owner of the  file  and  the
              caller was not privileged.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EROFS  pathname  refers  to  a  file  on a read-only filesystem and
              write access was requested.

       ETXTBSY
              pathname refers to an executable image  which  is  currently
              being executed and write access was requested.

       ETXTBSY
              pathname refers to a file that is currently in use as a swap
              file, and the O_TRUNC flag was specified.

       ETXTBSY
              pathname refers to a file that is currently  being  read  by
              the  kernel  (e.g.,  for module/firmware loading), and write
              access was requested.

       EWOULDBLOCK
              The O_NONBLOCK flag was specified, and an incompatible lease
              was held on the file (see fcntl(2)).

       The following additional errors can occur for openat():

       EBADF  dirfd is not a valid file descriptor.

       ENOTDIR
              pathname is a relative pathname and dirfd is a file descrip‐
              tor referring to a file other than a directory.

VERSIONS
       openat() was added to Linux in kernel 2.6.16; library  support  was
       added to glibc in version 2.4.

CONFORMING TO
       open(), creat() SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       openat(): POSIX.1-2008.

       openat2(2) is Linux-specific.

       The O_DIRECT, O_NOATIME, O_PATH, and O_TMPFILE flags are Linux-spe‐
       cific.  One must define _GNU_SOURCE to obtain their definitions.

       The O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW flags are not  specified
       in  POSIX.1-2001,  but  are specified in POSIX.1-2008.  Since glibc
       2.12,  one  can  obtain  their  definitions  by   defining   either
       _POSIX_C_SOURCE  with  a  value greater than or equal to 200809L or
       _XOPEN_SOURCE with a value greater than or equal to 700.  In  glibc
       2.11   and   earlier,  one  obtains  the  definitions  by  defining
       _GNU_SOURCE.

       As noted in feature_test_macros(7), feature  test  macros  such  as
       _POSIX_C_SOURCE, _XOPEN_SOURCE, and _GNU_SOURCE must be defined be‐
       fore including any header files.

NOTES
       Under Linux, the O_NONBLOCK flag is sometimes used in  cases  where
       one  wants  to  open but does not necessarily have the intention to
       read or write.  For example, this may be used to open a  device  in
       order to get a file descriptor for use with ioctl(2).

       The (undefined) effect of O_RDONLY | O_TRUNC varies among implemen‐
       tations.  On many systems the file is actually truncated.

       Note that open() can open device special files, but creat()  cannot
       create them; use mknod(2) instead.

       If  the  file  is  newly  created, its st_atime, st_ctime, st_mtime
       fields (respectively, time of last  access,  time  of  last  status
       change,  and time of last modification; see stat(2)) are set to the
       current time, and so are the st_ctime and st_mtime  fields  of  the
       parent  directory.   Otherwise,  if the file is modified because of
       the O_TRUNC flag, its st_ctime and st_mtime fields are set  to  the
       current time.

       The  files  in  the /proc/[pid]/fd directory show the open file de‐
       scriptors of the process with  the  PID  pid.   The  files  in  the
       /proc/[pid]/fdinfo directory show even more information about these
       file descriptors.  See proc(5) for further details of both of these
       directories.

       The  Linux  header  file  <asm/fcntl.h> doesn't define O_ASYNC; the
       (BSD-derived) FASYNC synonym is defined instead.

   Open file descriptions
       The term open file description is the one used by POSIX to refer to
       the  entries in the system-wide table of open files.  In other con‐
       texts, this object is variously also called an "open file  object",
       a "file handle", an "open file table entry", or—in kernel-developer
       parlance—a struct file.

       When a file descriptor is duplicated (using dup(2) or similar), the
       duplicate  refers to the same open file description as the original
       file descriptor, and the two file  descriptors  consequently  share
       the file offset and file status flags.  Such sharing can also occur
       between processes: a child process created via fork(2) inherits du‐
       plicates of its parent's file descriptors, and those duplicates re‐
       fer to the same open file descriptions.

       Each open() of a file creates a new open  file  description;  thus,
       there  may  be  multiple  open file descriptions corresponding to a
       file inode.

       On Linux, one can use  the  kcmp(2)  KCMP_FILE  operation  to  test
       whether two file descriptors (in the same process or in two differ‐
       ent processes) refer to the same open file description.

   Synchronized I/O
       The POSIX.1-2008  "synchronized  I/O"  option  specifies  different
       variants  of  synchronized  I/O,  and  specifies  the  open() flags
       O_SYNC, O_DSYNC, and O_RSYNC for controlling the behavior.  Regard‐
       less  of whether an implementation supports this option, it must at
       least support the use of O_SYNC for regular files.

       Linux implements O_SYNC and O_DSYNC, but not O_RSYNC.  Somewhat in‐
       correctly,  glibc defines O_RSYNC to have the same value as O_SYNC.
       (O_RSYNC is defined in the Linux header file  <asm/fcntl.h>  on  HP
       PA-RISC, but it is not used.)

       O_SYNC provides synchronized I/O file integrity completion, meaning
       write operations will flush data and all associated metadata to the
       underlying hardware.  O_DSYNC provides synchronized I/O data integ‐
       rity completion, meaning write operations will flush  data  to  the
       underlying  hardware, but will only flush metadata updates that are
       required to allow a subsequent read operation to complete  success‐
       fully.  Data integrity completion can reduce the number of disk op‐
       erations that are required for applications  that  don't  need  the
       guarantees of file integrity completion.

       To  understand  the difference between the two types of completion,
       consider two pieces of file metadata: the  file  last  modification
       timestamp  (st_mtime)  and  the  file length.  All write operations
       will update the last file modification timestamp, but  only  writes
       that  add  data to the end of the file will change the file length.
       The last modification timestamp is not needed to ensure that a read
       completes  successfully,  but  the  file  length is.  Thus, O_DSYNC
       would only guarantee to flush updates to the file  length  metadata
       (whereas O_SYNC would also always flush the last modification time‐
       stamp metadata).

       Before Linux 2.6.33, Linux implemented only  the  O_SYNC  flag  for
       open().   However,  when  that flag was specified, most filesystems
       actually provided the equivalent of synchronized I/O data integrity
       completion (i.e., O_SYNC was actually implemented as the equivalent
       of O_DSYNC).

       Since Linux 2.6.33, proper O_SYNC support is provided.  However, to
       ensure  backward binary compatibility, O_DSYNC was defined with the
       same value as the historical O_SYNC, and O_SYNC was  defined  as  a
       new  (two-bit)  flag  value  that  includes the O_DSYNC flag value.
       This ensures that applications compiled against new headers get  at
       least O_DSYNC semantics on pre-2.6.33 kernels.

   C library/kernel differences
       Since  version  2.26, the glibc wrapper function for open() employs
       the openat() system call, rather than the  kernel's  open()  system
       call.   For  certain architectures, this is also true in glibc ver‐
       sions before 2.26.

   NFS
       There are many infelicities in the protocol underlying NFS, affect‐
       ing amongst others O_SYNC and O_NDELAY.

       On  NFS  filesystems  with UID mapping enabled, open() may return a
       file descriptor but, for example, read(2) requests are denied  with
       EACCES.  This is because the client performs open() by checking the
       permissions, but UID mapping is performed by the server  upon  read
       and write requests.

   FIFOs
       Opening  the read or write end of a FIFO blocks until the other end
       is also opened (by another process or  thread).   See  fifo(7)  for
       further details.

   File access mode
       Unlike  the other values that can be specified in flags, the access
       mode values O_RDONLY, O_WRONLY, and O_RDWR do not specify  individ‐
       ual bits.  Rather, they define the low order two bits of flags, and
       are defined respectively as 0, 1, and 2.  In other words, the  com‐
       bination O_RDONLY | O_WRONLY is a logical error, and certainly does
       not have the same meaning as O_RDWR.

       Linux reserves the special, nonstandard access mode 3  (binary  11)
       in  flags  to mean: check for read and write permission on the file
       and return a file descriptor that can't  be  used  for  reading  or
       writing.   This nonstandard access mode is used by some Linux driv‐
       ers to return a file descriptor that is to be used only for device-
       specific ioctl(2) operations.

   Rationale for openat() and other directory file descriptor APIs
       openat() and the other system calls and library functions that take
       a directory file descriptor argument  (i.e.,  execveat(2),  facces‐
       sat(2),  fanotify_mark(2), fchmodat(2), fchownat(2), fspick(2), fs‐
       tatat(2), futimesat(2), linkat(2), mkdirat(2), move_mount(2), mkno‐
       dat(2),   name_to_handle_at(2),   open_tree(2),  openat2(2),  read‐
       linkat(2), renameat(2), statx(2), symlinkat(2),  unlinkat(2),  uti‐
       mensat(2), mkfifoat(3), and scandirat(3)) address two problems with
       the older interfaces that preceded them.  Here, the explanation  is
       in  terms  of the openat() call, but the rationale is analogous for
       the other interfaces.

       First, openat() allows an application to avoid race conditions that
       could  occur  when  using open() to open files in directories other
       than the current working directory.  These race  conditions  result
       from  the fact that some component of the directory prefix given to
       open() could be changed in parallel with the call to open().   Sup‐
       pose,   for   example,   that   we   wish   to   create   the  file
       dir1/dir2/xxx.dep if the file dir1/dir2/xxx exists.  The problem is
       that  between  the existence check and the file-creation step, dir1
       or dir2 (which might be symbolic links) could be modified to  point
       to  a  different  location.  Such races can be avoided by opening a
       file descriptor for the target directory, and then specifying  that
       file  descriptor as the dirfd argument of (say) fstatat(2) and ope‐
       nat().  The use of the dirfd file descriptor also has  other  bene‐
       fits:

       *  the file descriptor is a stable reference to the directory, even
          if the directory is renamed; and

       *  the open file descriptor prevents the underlying filesystem from
          being  dismounted,  just as when a process has a current working
          directory on a filesystem.

       Second, openat() allows the implementation of a per-thread "current
       working directory", via file descriptor(s) maintained by the appli‐
       cation.  (This functionality can also be obtained by  tricks  based
       on the use of /proc/self/fd/dirfd, but less efficiently.)

       The  dirfd  argument for these APIs can be obtained by using open()
       or openat() to open a directory (with either the  O_RDONLY  or  the
       O_PATH  flag).   Alternatively,  such  a file descriptor can be ob‐
       tained by applying dirfd(3) to a  directory  stream  created  using
       opendir(3).

       When these APIs are given a dirfd argument of AT_FDCWD or the spec‐
       ified pathname is absolute, then they handle their  pathname  argu‐
       ment  in the same way as the corresponding conventional APIs.  How‐
       ever, in this case, several of the APIs have a flags argument  that
       provides  access  to  functionality  that is not available with the
       corresponding conventional APIs.

   O_DIRECT
       The O_DIRECT flag may impose alignment restrictions on  the  length
       and  address of user-space buffers and the file offset of I/Os.  In
       Linux alignment restrictions vary by filesystem and kernel  version
       and  might  be  absent  entirely.   However  there  is currently no
       filesystem-independent interface for  an  application  to  discover
       these  restrictions  for a given file or filesystem.  Some filesys‐
       tems provide their own interfaces for doing  so,  for  example  the
       XFS_IOC_DIOINFO operation in xfsctl(3).

       Under Linux 2.4, transfer sizes, and the alignment of the user buf‐
       fer and the file offset must all be multiples of the logical  block
       size  of the filesystem.  Since Linux 2.6.0, alignment to the logi‐
       cal block size of the underlying storage (typically 512 bytes) suf‐
       fices.  The logical block size can be determined using the ioctl(2)
       BLKSSZGET operation or from the shell using the command:

           blockdev --getss

       O_DIRECT I/Os should never be run  concurrently  with  the  fork(2)
       system  call,  if the memory buffer is a private mapping (i.e., any
       mapping created with the mmap(2) MAP_PRIVATE  flag;  this  includes
       memory  allocated  on  the  heap and statically allocated buffers).
       Any such I/Os, whether submitted via an asynchronous I/O  interface
       or  from  another thread in the process, should be completed before
       fork(2) is called.  Failure to do so can result in data  corruption
       and  undefined  behavior  in  parent and child processes.  This re‐
       striction does not apply when the memory buffer  for  the  O_DIRECT
       I/Os  was  created  using  shmat(2)  or mmap(2) with the MAP_SHARED
       flag.  Nor does this restriction apply when the memory  buffer  has
       been  advised  as  MADV_DONTFORK  with madvise(2), ensuring that it
       will not be available to the child after fork(2).

       The O_DIRECT flag was introduced in SGI IRIX, where it  has  align‐
       ment  restrictions  similar to those of Linux 2.4.  IRIX has also a
       fcntl(2) call to query appropriate alignments, and sizes.   FreeBSD
       4.x  introduced  a flag of the same name, but without alignment re‐
       strictions.

       O_DIRECT support was added under Linux in  kernel  version  2.4.10.
       Older  Linux kernels simply ignore this flag.  Some filesystems may
       not implement the flag, in which case open() fails with  the  error
       EINVAL if it is used.

       Applications  should  avoid  mixing  O_DIRECT and normal I/O to the
       same file, and especially to overlapping byte regions in  the  same
       file.  Even when the filesystem correctly handles the coherency is‐
       sues in this situation, overall I/O  throughput  is  likely  to  be
       slower than using either mode alone.  Likewise, applications should
       avoid mixing mmap(2) of files with direct I/O to the same files.

       The behavior of O_DIRECT with NFS will differ from  local  filesys‐
       tems.   Older  kernels,  or kernels configured in certain ways, may
       not support this combination.  The NFS protocol  does  not  support
       passing  the  flag  to  the server, so O_DIRECT I/O will bypass the
       page cache only on the client; the server may still cache the  I/O.
       The  client asks the server to make the I/O synchronous to preserve
       the synchronous semantics of O_DIRECT.  Some servers  will  perform
       poorly  under  these  circumstances,  especially if the I/O size is
       small.  Some servers may also be configured to lie to clients about
       the  I/O having reached stable storage; this will avoid the perfor‐
       mance penalty at some risk to data integrity in the event of server
       power  failure.   The Linux NFS client places no alignment restric‐
       tions on O_DIRECT I/O.

       In summary, O_DIRECT is a potentially powerful tool that should  be
       used  with  caution.  It is recommended that applications treat use
       of O_DIRECT as a performance option which is disabled by default.

BUGS
       Currently, it is not possible to enable signal-driven I/O by speci‐
       fying  O_ASYNC  when  calling  open();  use fcntl(2) to enable this
       flag.

       One must check for two different error codes,  EISDIR  and  ENOENT,
       when  trying  to  determine  whether  the kernel supports O_TMPFILE
       functionality.

       When both O_CREAT and O_DIRECTORY are specified in  flags  and  the
       file  specified  by  pathname  does not exist, open() will create a
       regular file (i.e., O_DIRECTORY is ignored).

SEE ALSO
       chmod(2), chown(2), close(2), dup(2), fcntl(2), link(2),  lseek(2),
       mknod(2),   mmap(2),  mount(2),  open_by_handle_at(2),  openat2(2),
       read(2),  socket(2),  stat(2),   umask(2),   unlink(2),   write(2),
       fopen(3), acl(5), fifo(7), inode(7), path_resolution(7), symlink(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-11-01                         OPEN(2)
OPENDIR(3)               Linux Programmer's Manual              OPENDIR(3)

NAME
       opendir, fdopendir - open a directory

SYNOPSIS
       #include <sys/types.h>
       #include <dirent.h>

       DIR *opendir(const char *name);
       DIR *fdopendir(int fd);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fdopendir():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _GNU_SOURCE

DESCRIPTION
       The  opendir()  function  opens a directory stream corresponding to
       the directory name, and returns a pointer to the directory  stream.
       The stream is positioned at the first entry in the directory.

       The fdopendir() function is like opendir(), but returns a directory
       stream for the directory referred to by the  open  file  descriptor
       fd.   After a successful call to fdopendir(), fd is used internally
       by the implementation, and should not otherwise be used by the  ap‐
       plication.

RETURN VALUE
       The opendir() and fdopendir() functions return a pointer to the di‐
       rectory stream.  On error, NULL is returned, and errno is  set  ap‐
       propriately.

ERRORS
       EACCES Permission denied.

       EBADF  fd is not a valid file descriptor opened for reading.

       EMFILE The per-process limit on the number of open file descriptors
              has been reached.

       ENFILE The system-wide limit on the total number of open files  has
              been reached.

       ENOENT Directory does not exist, or name is an empty string.

       ENOMEM Insufficient memory to complete the operation.

       ENOTDIR
              name is not a directory.

VERSIONS
       fdopendir() is available in glibc since version 2.4.

ATTRIBUTES
       For  an  explanation  of  the  terms  used in this section, see at‐
       tributes(7).

       ┌───────────────────────┬───────────────┬─────────┐
       │Interface              │ Attribute     │ Value   │
       ├───────────────────────┼───────────────┼─────────┤
       │opendir(), fdopendir() │ Thread safety │ MT-Safe │
       └───────────────────────┴───────────────┴─────────┘
CONFORMING TO
       opendir()  is  present  on   SVr4,   4.3BSD,   and   specified   in
       POSIX.1-2001.  fdopendir() is specified in POSIX.1-2008.

NOTES
       Filename  entries  can  be read from a directory stream using read‐
       dir(3).

       The underlying file descriptor of the directory stream can  be  ob‐
       tained using dirfd(3).

       The opendir() function sets the close-on-exec flag for the file de‐
       scriptor underlying the DIR *.  The fdopendir() function leaves the
       setting  of  the close-on-exec flag unchanged for the file descrip‐
       tor, fd.  POSIX.1-200x leaves it unspecified whether  a  successful
       call  to  fdopendir()  will set the close-on-exec flag for the file
       descriptor, fd.

SEE ALSO
       open(2), closedir(3),  dirfd(3),  readdir(3),  rewinddir(3),  scan‐
       dir(3), seekdir(3), telldir(3)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

GNU                             2017-09-15                      OPENDIR(3)
PERROR(3)                Linux Programmer's Manual               PERROR(3)

NAME
       perror - print a system error message

SYNOPSIS
       #include <stdio.h>

       void perror(const char *s);

       #include <errno.h>

       const char * const sys_errlist[];
       int sys_nerr;
       int errno;       /* Not really declared this way; see errno(3) */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       sys_errlist, sys_nerr:
           From glibc 2.19 to 2.31:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE

DESCRIPTION
       The perror() function produces a message on standard error describ‐
       ing the last error encountered during a call to a system or library
       function.

       First  (if s is not NULL and *s is not a null byte ('\0')), the ar‐
       gument string s is printed, followed by a colon and a blank.   Then
       an  error message corresponding to the current value of errno and a
       new-line.

       To be of most use, the argument string should include the  name  of
       the function that incurred the error.

       The global error list sys_errlist[], which can be indexed by errno,
       can be used to obtain the error message without the  newline.   The
       largest  message  number  provided  in the table is sys_nerr-1.  Be
       careful when directly accessing this list, because new error values
       may not have been added to sys_errlist[].  The use of sys_errlist[]
       is nowadays deprecated; use strerror(3) instead.

       When a system call fails, it usually returns -1 and sets the  vari‐
       able  errno  to  a value describing what went wrong.  (These values
       can be found in <errno.h>.)  Many library  functions  do  likewise.
       The  function perror() serves to translate this error code into hu‐
       man-readable form.  Note that errno is undefined after a successful
       system  call  or  library  function call: this call may well change
       this variable, even though it succeeds, for example because it  in‐
       ternally  used some other library function that failed.  Thus, if a
       failing call is not immediately followed by a call to perror(), the
       value of errno should be saved.

VERSIONS
       Since  glibc  version  2.32,  the  declarations  of sys_errlist and
       sys_nerr are no longer exposed by <stdio.h>.

ATTRIBUTES
       For an explanation of the terms  used  in  this  section,  see  at‐
       tributes(7).

       ┌──────────┬───────────────┬─────────────────────┐
       │Interface │ Attribute     │ Value               │
       ├──────────┼───────────────┼─────────────────────┤
       │perror()  │ Thread safety │ MT-Safe race:stderr │
       └──────────┴───────────────┴─────────────────────┘

CONFORMING TO
       perror(), errno: POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD.

       The externals sys_nerr and sys_errlist derive from BSD, but are not
       specified in POSIX.1.

NOTES
       The externals sys_nerr and sys_errlist are defined by glibc, but in
       <stdio.h>.

SEE ALSO
       err(3), errno(3), error(3), strerror(3)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

                                2020-11-01                       PERROR(3)
READ(2)                  Linux Programmer's Manual                 READ(2)

NAME
       read - read from a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t read(int fd, void *buf, size_t count);

DESCRIPTION
       read()  attempts  to read up to count bytes from file descriptor fd
       into the buffer starting at buf.

       On files that support seeking, the read operation commences at  the
       file  offset,  and  the file offset is incremented by the number of
       bytes read.  If the file offset is at or past the end of  file,  no
       bytes are read, and read() returns zero.

       If count is zero, read() may detect the errors described below.  In
       the absence of any errors, or if read() does not check for  errors,
       a read() with a count of 0 returns zero and has no other effects.

       According  to  POSIX.1, if count is greater than SSIZE_MAX, the re‐
       sult is implementation-defined; see NOTES for the  upper  limit  on
       Linux.

RETURN VALUE
       On  success,  the  number of bytes read is returned (zero indicates
       end of file), and the file position is advanced by this number.  It
       is  not an error if this number is smaller than the number of bytes
       requested; this may happen for example because fewer bytes are  ac‐
       tually  available right now (maybe because we were close to end-of-
       file, or because we are reading from a pipe, or from  a  terminal),
       or because read() was interrupted by a signal.  See also NOTES.

       On  error, -1 is returned, and errno is set appropriately.  In this
       case, it is left unspecified whether the  file  position  (if  any)
       changes.

ERRORS
       EAGAIN The  file descriptor fd refers to a file other than a socket
              and has been marked nonblocking (O_NONBLOCK), and  the  read
              would  block.  See open(2) for further details on the O_NON‐
              BLOCK flag.

       EAGAIN or EWOULDBLOCK
              The file descriptor fd refers  to  a  socket  and  has  been
              marked  nonblocking  (O_NONBLOCK), and the read would block.
              POSIX.1-2001 allows either error to  be  returned  for  this
              case,  and does not require these constants to have the same
              value, so a portable application should check for both  pos‐
              sibilities.

       EBADF  fd  is  not a valid file descriptor or is not open for read‐
              ing.

       EFAULT buf is outside your accessible address space.

       EINTR  The call was interrupted by a signal  before  any  data  was
              read; see signal(7).

       EINVAL fd is attached to an object which is unsuitable for reading;
              or the file was opened with the O_DIRECT  flag,  and  either
              the  address specified in buf, the value specified in count,
              or the file offset is not suitably aligned.

       EINVAL fd was created via a call to timerfd_create(2) and the wrong
              size  buffer  was given to read(); see timerfd_create(2) for
              further information.

       EIO    I/O error.  This will happen for example when the process is
              in  a  background process group, tries to read from its con‐
              trolling terminal, and either it  is  ignoring  or  blocking
              SIGTTIN or its process group is orphaned.  It may also occur
              when there is a low-level I/O error  while  reading  from  a
              disk  or tape.  A further possible cause of EIO on networked
              filesystems is when an advisory lock had been taken  out  on
              the  file  descriptor  and this lock has been lost.  See the
              Lost locks section of fcntl(2) for further details.

       EISDIR fd refers to a directory.

       Other errors may occur, depending on the object connected to fd.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
       The types size_t and ssize_t are, respectively, unsigned and signed
       integer data types specified by POSIX.1.

       On  Linux,  read() (and similar system calls) will transfer at most
       0x7ffff000 (2,147,479,552) bytes, returning the number of bytes ac‐
       tually  transferred.   (This is true on both 32-bit and 64-bit sys‐
       tems.)

       On NFS filesystems, reading small amounts of data will  update  the
       timestamp  only  the  first  time,  subsequent calls may not do so.
       This is caused by client side attribute caching,  because  most  if
       not  all NFS clients leave st_atime (last file access time) updates
       to the server, and client side reads satisfied  from  the  client's
       cache will not cause st_atime updates on the server as there are no
       server-side reads.  UNIX semantics can  be  obtained  by  disabling
       client-side  attribute  caching,  but  in most situations this will
       substantially increase server load and decrease performance.

BUGS
       According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 ("Thread Interac‐
       tions with Regular File Operations"):

           All  of the following functions shall be atomic with respect to
           each other in the effects specified in POSIX.1-2008  when  they
           operate on regular files or symbolic links: ...

       Among  the  APIs  subsequently listed are read() and readv(2).  And
       among the effects that should be atomic across  threads  (and  pro‐
       cesses)  are  updates of the file offset.  However, on Linux before
       version 3.14, this was not the case: if two processes that share an
       open  file description (see open(2)) perform a read() (or readv(2))
       at the same time, then the I/O operations were not atomic with  re‐
       spect  updating  the file offset, with the result that the reads in
       the two processes might (incorrectly) overlap in the blocks of data
       that they obtained.  This problem was fixed in Linux 3.14.

SEE ALSO
       close(2),  fcntl(2),  ioctl(2),  lseek(2), open(2), pread(2), read‐
       dir(2), readlink(2), readv(2), select(2), write(2), fread(3)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2018-02-02                         READ(2)
READDIR(3)               Linux Programmer's Manual              READDIR(3)

NAME
       readdir - read a directory

SYNOPSIS
       #include <dirent.h>

       struct dirent *readdir(DIR *dirp);

DESCRIPTION
       The readdir() function returns a pointer to a dirent structure rep‐
       resenting the next directory entry in the directory stream  pointed
       to  by  dirp.  It returns NULL on reaching the end of the directory
       stream or if an error occurred.

       In the glibc implementation, the dirent  structure  is  defined  as
       follows:

           struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };

       The  only  fields  in  the  dirent  structure  that are mandated by
       POSIX.1 are d_name and d_ino.  The other fields are unstandardized,
       and  not  present  on all systems; see NOTES below for some further
       details.

       The fields of the dirent structure are as follows:

       d_ino  This is the inode number of the file.

       d_off  The value returned in d_off is the same as would be returned
              by  calling telldir(3) at the current position in the direc‐
              tory stream.  Be aware that despite its type and  name,  the
              d_off field is seldom any kind of directory offset on modern
              filesystems.  Applications should treat  this  field  as  an
              opaque  value, making no assumptions about its contents; see
              also telldir(3).

       d_reclen
              This is the size (in bytes) of the  returned  record.   This
              may  not  match  the  size of the structure definition shown
              above; see NOTES.

       d_type This field contains a value indicating the file type, making
              it possible to avoid the expense of calling lstat(2) if fur‐
              ther actions depend on the type of the file.

              When  a  suitable  feature  test  macro  is  defined   (_DE‐
              FAULT_SOURCE on glibc versions since 2.19, or _BSD_SOURCE on
              glibc versions 2.19 and earlier), glibc defines the  follow‐
              ing macro constants for the value returned in d_type:

              DT_BLK      This is a block device.

              DT_CHR      This is a character device.

              DT_DIR      This is a directory.

              DT_FIFO     This is a named pipe (FIFO).

              DT_LNK      This is a symbolic link.

              DT_REG      This is a regular file.

              DT_SOCK     This is a UNIX domain socket.

              DT_UNKNOWN  The file type could not be determined.

              Currently,  only  some filesystems (among them: Btrfs, ext2,
              ext3, and ext4) have full support  for  returning  the  file
              type in d_type.  All applications must properly handle a re‐
              turn of DT_UNKNOWN.

       d_name This field  contains  the  null  terminated  filename.   See
              NOTES.

       The  data  returned  by  readdir() may be overwritten by subsequent
       calls to readdir() for the same directory stream.

RETURN VALUE
       On success, readdir() returns a  pointer  to  a  dirent  structure.
       (This  structure  may  be  statically  allocated; do not attempt to
       free(3) it.)

       If the end of the directory stream is reached, NULL is returned and
       errno is not changed.  If an error occurs, NULL is returned and er‐
       rno is set appropriately.  To distinguish end of stream from an er‐
       ror,  set errno to zero before calling readdir() and then check the
       value of errno if NULL is returned.

ERRORS
       EBADF  Invalid directory stream descriptor dirp.

ATTRIBUTES
       For an explanation of the terms  used  in  this  section,  see  at‐
       tributes(7).

       ┌──────────┬───────────────┬──────────────────────────┐
       │Interface │ Attribute     │ Value                    │
       ├──────────┼───────────────┼──────────────────────────┤
       │readdir() │ Thread safety │ MT-Unsafe race:dirstream │
       └──────────┴───────────────┴──────────────────────────┘

       In  the  current POSIX.1 specification (POSIX.1-2008), readdir() is
       not required to be thread-safe.  However, in modern implementations
       (including the glibc implementation), concurrent calls to readdir()
       that specify different directory streams are thread-safe.  In cases
       where  multiple  threads  must read from the same directory stream,
       using readdir() with external synchronization is  still  preferable
       to the use of the deprecated readdir_r(3) function.  It is expected
       that a future version of POSIX.1 will  require  that  readdir()  be
       thread-safe  when  concurrently  employed  on  different  directory
       streams.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.

NOTES
       A directory stream is opened using opendir(3).

       The order in which filenames are read by successive calls to  read‐
       dir() depends on the filesystem implementation; it is unlikely that
       the names will be sorted in any fashion.

       Only the fields d_name and (as an XSI extension) d_ino  are  speci‐
       fied  in  POSIX.1.  Other than Linux, the d_type field is available
       mainly only on BSD systems.  The remaining fields are available  on
       many, but not all systems.  Under glibc, programs can check for the
       availability of the  fields  not  defined  in  POSIX.1  by  testing
       whether  the  macros  _DIRENT_HAVE_D_NAMLEN, _DIRENT_HAVE_D_RECLEN,
       _DIRENT_HAVE_D_OFF, or _DIRENT_HAVE_D_TYPE are defined.

   The d_name field
       The dirent structure definition shown above is taken from the glibc
       headers, and shows the d_name field with a fixed size.

       Warning:  applications  should  avoid any dependence on the size of
       the d_name field.  POSIX defines it as char d_name[],  a  character
       array of unspecified size, with at most NAME_MAX characters preced‐
       ing the terminating null byte ('\0').

       POSIX.1 explicitly notes that this field should not be used  as  an
       lvalue.   The standard also notes that the use of sizeof(d_name) is
       incorrect; use strlen(d_name)  instead.   (On  some  systems,  this
       field  is  defined  as  char d_name[1]!)   By  implication, the use
       sizeof(struct dirent) to capture the size of the  record  including
       the size of d_name is also incorrect.

       Note that while the call

           fpathconf(fd, _PC_NAME_MAX)

       returns  the  value  255  for most filesystems, on some filesystems
       (e.g., CIFS, Windows SMB  servers),  the  null-terminated  filename
       that  is  (correctly)  returned  in d_name can actually exceed this
       size.  In such cases, the d_reclen field will contain a value  that
       exceeds the size of the glibc dirent structure shown above.

SEE ALSO
       getdents(2),  read(2),  closedir(3), dirfd(3), ftw(3), offsetof(3),
       opendir(3),  readdir_r(3),  rewinddir(3),  scandir(3),  seekdir(3),
       telldir(3)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

                                2019-03-06                      READDIR(3)
SIGNAL(2)                Linux Programmer's Manual               SIGNAL(2)

NAME
       signal - ANSI C signal handling

SYNOPSIS
       #include <signal.h>

       typedef void (*sighandler_t)(int);

       sighandler_t signal(int signum, sighandler_t handler);

DESCRIPTION
       WARNING:
        the behavior of signal() varies across UNIX versions, and has also
       varied historically across different versions of Linux.  Avoid  its
       use: use sigaction(2) instead.  See Portability below.

       signal()  sets  the  disposition  of  the signal signum to handler,
       which is either SIG_IGN, SIG_DFL, or the address of  a  programmer-
       defined function (a "signal handler").

       If  the  signal signum is delivered to the process, then one of the
       following happens:

       *  If the disposition is set to SIG_IGN, then  the  signal  is  ig‐
          nored.

       *  If  the  disposition  is set to SIG_DFL, then the default action
          associated with the signal (see signal(7)) occurs.

       *  If the disposition is set to a function, then first  either  the
          disposition  is  reset to SIG_DFL, or the signal is blocked (see
          Portability below), and then handler  is  called  with  argument
          signum.   If  invocation  of the handler caused the signal to be
          blocked, then the signal is unblocked upon return from the  han‐
          dler.

       The signals SIGKILL and SIGSTOP cannot be caught or ignored.

RETURN VALUE
       signal()  returns  the  previous  value  of  the signal handler, or
       SIG_ERR on error.  In the event of an error, errno is set to  indi‐
       cate the cause.

ERRORS
       EINVAL signum is invalid.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008, C89, C99.

NOTES
       The effects of signal() in a multithreaded process are unspecified.

       According to POSIX, the behavior of a process is undefined after it
       ignores a SIGFPE, SIGILL, or SIGSEGV signal that was not  generated
       by kill(2) or raise(3).  Integer division by zero has undefined re‐
       sult.  On some architectures it  will  generate  a  SIGFPE  signal.
       (Also  dividing  the  most  negative  integer  by  -1  may generate
       SIGFPE.)  Ignoring this signal might lead to an endless loop.

       See sigaction(2) for details on what happens when  the  disposition
       SIGCHLD is set to SIG_IGN.

       See  signal-safety(7) for a list of the async-signal-safe functions
       that can be safely called from inside a signal handler.

       The use of sighandler_t is a GNU extension, exposed if  _GNU_SOURCE
       is   defined;   glibc  also  defines  (the  BSD-derived)  sig_t  if
       _BSD_SOURCE (glibc 2.19 and earlier) or _DEFAULT_SOURCE (glibc 2.19
       and later) is defined.  Without use of such a type, the declaration
       of signal() is the somewhat harder to read:

           void ( *signal(int signum, void (*handler)(int)) ) (int);

   Portability
       The only portable use of signal() is to set a signal's  disposition
       to SIG_DFL or SIG_IGN.  The semantics when using signal() to estab‐
       lish a signal handler vary across systems (and  POSIX.1  explicitly
       permits this variation); do not use it for this purpose.

       POSIX.1  solved  the  portability  mess by specifying sigaction(2),
       which provides explicit control of the semantics when a signal han‐
       dler is invoked; use that interface instead of signal().

       In  the  original UNIX systems, when a handler that was established
       using signal() was invoked by the delivery of a signal, the  dispo‐
       sition  of the signal would be reset to SIG_DFL, and the system did
       not block delivery of further instances of  the  signal.   This  is
       equivalent to calling sigaction(2) with the following flags:

           sa.sa_flags = SA_RESETHAND | SA_NODEFER;

       System V  also provides these semantics for signal().  This was bad
       because the signal might be delivered again before the handler  had
       a  chance  to reestablish itself.  Furthermore, rapid deliveries of
       the same signal could result in recursive invocations of  the  han‐
       dler.

       BSD  improved on this situation, but unfortunately also changed the
       semantics of the existing signal() interface while  doing  so.   On
       BSD,  when  a  signal handler is invoked, the signal disposition is
       not reset, and further instances of the signal are blocked from be‐
       ing delivered while the handler is executing.  Furthermore, certain
       blocking system calls are automatically restarted if interrupted by
       a signal handler (see signal(7)).  The BSD semantics are equivalent
       to calling sigaction(2) with the following flags:

           sa.sa_flags = SA_RESTART;

       The situation on Linux is as follows:

       * The kernel's signal() system call provides System V semantics.

       * By default, in glibc 2 and later, the signal()  wrapper  function
         does not invoke the kernel system call.  Instead, it calls sigac‐
         tion(2) using flags that supply BSD semantics.  This default  be‐
         havior  is  provided  as long as a suitable feature test macro is
         defined: _BSD_SOURCE on glibc 2.19 and earlier or _DEFAULT_SOURCE
         in  glibc 2.19 and later.  (By default, these macros are defined;
         see feature_test_macros(7) for details.)  If such a feature  test
         macro is not defined, then signal() provides System V semantics.

SEE ALSO
       kill(1),  alarm(2),  kill(2),  pause(2), sigaction(2), signalfd(2),
       sigpending(2),   sigprocmask(2),   sigsuspend(2),    bsd_signal(3),
       killpg(3),  raise(3),  siginterrupt(3),  sigqueue(3), sigsetops(3),
       sigvec(3), sysv_signal(3), signal(7)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2017-09-15                       SIGNAL(2)
STAT(2)                  Linux Programmer's Manual                 STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions  return  information  about  a file, in the buffer
       pointed to by statbuf.  No permissions are required on the file it‐
       self,  but—in  the  case  of stat(), fstatat(), and lstat()—execute
       (search) permission is required on all of the directories in  path‐
       name that lead to the file.

       stat() and fstatat() retrieve information about the file pointed to
       by pathname; the differences for fstatat() are described below.

       lstat() is identical to stat(), except that if pathname is  a  sym‐
       bolic  link, then it returns information about the link itself, not
       the file that the link refers to.

       fstat() is identical to stat(), except that the  file  about  which
       information  is to be retrieved is specified by the file descriptor
       fd.

   The stat structure
       All of these system calls return a stat structure,  which  contains
       the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note:  the  order  of  fields in the stat structure varies somewhat
       across architectures.  In addition, the definition above  does  not
       show  the  padding bytes that may be present between some fields on
       various architectures.  Consult the glibc and kernel source code if
       you need to know the details.

       Note:  for  performance and simplicity reasons, different fields in
       the stat structure may contain state information from different mo‐
       ments  during  the  execution  of the system call.  For example, if
       st_mode or st_uid is changed by another process by calling chmod(2)
       or  chown(2), stat() might return the old st_mode together with the
       new st_uid, or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file  resides.
              (The major(3) and minor(3) macros may be useful to decompose
              the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and  mode.   See  inode(7)
              for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This  field describes the device that this file (inode) rep‐
              resents.

       st_size
              This field gives the size of the file (if it  is  a  regular
              file  or  a symbolic link) in bytes.  The size of a symbolic
              link is the length of the pathname it  contains,  without  a
              terminating null byte.

       st_blksize
              This  field  gives  the "preferred" block size for efficient
              filesystem I/O.

       st_blocks
              This field indicates the number of blocks allocated  to  the
              file,   in  512-byte  units.   (This  may  be  smaller  than
              st_size/512 when the file has holes.)

       st_atime
              This is the time of the last access of file data.

       st_mtime
              This is the time of last modification of file data.

       st_ctime
              This is the file's last status  change  timestamp  (time  of
              last change to the inode).

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for accessing
       file information which can still provide exactly  the  behavior  of
       each of stat(), lstat(), and fstat().

       If  the  pathname  given in pathname is relative, then it is inter‐
       preted relative to the directory referred to by the file descriptor
       dirfd (rather than relative to the current working directory of the
       calling process, as is done by stat() and lstat()  for  a  relative
       pathname).

       If  pathname  is  relative and dirfd is the special value AT_FDCWD,
       then pathname is interpreted relative to the current working direc‐
       tory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags  can  either  be  0,  or include one or more of the following
       flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred
              to  by dirfd (which may have been obtained using the open(2)
              O_PATH flag).  In this case, dirfd can refer to any type  of
              file, not just a directory, and the behavior of fstatat() is
              similar to that of fstat().  If dirfd is AT_FDCWD, the  call
              operates  on  the  current  working directory.  This flag is
              Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't automount the terminal ("basename") component of path‐
              name  if it is a directory that is an automount point.  This
              allows the caller to gather attributes of an automount point
              (rather  than  the  location  it  would mount).  Since Linux
              4.14, also don't instantiate a nonexistent name in an on-de‐
              mand  directory  such as used for automounter indirect maps.
              This flag has no effect if the mount point has already  been
              mounted over.

              Both  stat()  and  lstat() act as though AT_NO_AUTOMOUNT was
              set.

              The AT_NO_AUTOMOUNT can be used in tools that scan  directo‐
              ries  to  prevent  mass-automounting of a directory of auto‐
              mount points.

              This flag is Linux-specific; define  _GNU_SOURCE  to  obtain
              its definition.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is a symbolic link, do not dereference it: in‐
              stead  return  information  about  the  link  itself,   like
              lstat().    (By  default,  fstatat()  dereferences  symbolic
              links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and  errno
       is set appropriately.

ERRORS
       EACCES Search  permission  is  denied for one of the directories in
              the path prefix of pathname.  (See also path_resolution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links  encountered  while  traversing  the
              path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling sym‐
              bolic link.

       ENOENT pathname is an empty string and AT_EMPTY_PATH was not speci‐
              fied in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A  component  of the path prefix of pathname is not a direc‐
              tory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or
              number of blocks cannot be represented in, respectively, the
              types off_t, ino_t, or blkcnt_t.  This error can occur when,
              for  example,  an  application compiled on a 32-bit platform
              without -D_FILE_OFFSET_BITS=64 calls stat() on a file  whose
              size exceeds (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname  is  relative and dirfd is a file descriptor refer‐
              ring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support  was
       added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return
       valid information only in the st_size field and the  file  type  of
       the st_mode field of the stat structure.  POSIX.1-2008 tightens the
       specification, requiring lstat() to return valid information in all
       fields except the mode bits in st_mode.

       Use  of  the  st_blocks and st_blksize fields may be less portable.
       (They were introduced in BSD.  The interpretation  differs  between
       systems,  and  possibly  on a single system when NFS mounts are in‐
       volved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond  time‐
       stamp fields.  Instead, there were three timestamp fields—st_atime,
       st_mtime, and st_ctime—typed as  time_t  that  recorded  timestamps
       with one-second precision.

       Since kernel 2.5.48, the stat structure supports nanosecond resolu‐
       tion for the three file timestamp fields.   The  nanosecond  compo‐
       nents  of  each  timestamp  are  available  via  names  of the form
       st_atim.tv_nsec, if  suitable  feature  test  macros  are  defined.
       Nanosecond  timestamps  were  standardized  in  POSIX.1-2008,  and,
       starting with version 2.12, glibc exposes the nanosecond  component
       names  if  _POSIX_C_SOURCE  is  defined  with  the value 200809L or
       greater, or _XOPEN_SOURCE is defined with the value 700 or greater.
       Up  to and including glibc 2.19, the definitions of the nanoseconds
       components are also defined if _BSD_SOURCE or _SVID_SOURCE  is  de‐
       fined.   If none of the aforementioned macros are defined, then the
       nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over time, increases in the size of the stat structure have led  to
       three  successive  versions  of  stat(): sys_stat() (slot __NR_old‐
       stat),  sys_newstat()  (slot  __NR_stat),  and  sys_stat64()  (slot
       __NR_stat64)  on 32-bit platforms such as i386.  The first two ver‐
       sions were already present in  Linux  1.0  (albeit  with  different
       names); the last was added in Linux 2.4.  Similar remarks apply for
       fstat() and lstat().

       The kernel-internal versions of the stat structure  dealt  with  by
       the different versions are, respectively:

       __old_kernel_stat
              The  original  structure,  with rather narrow fields, and no
              padding.

       stat   Larger st_ino field and padding added to  various  parts  of
              the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to
              accommodate the Linux-2.4 expansion of UIDs and GIDs  to  32
              bits,  and various other enlarged fields and further padding
              in the structure.  (Various padding  bytes  were  eventually
              consumed  in Linux 2.6, with the advent of 32-bit device IDs
              and nanosecond components for the timestamp fields.)

       The glibc stat() wrapper function hides these details from applica‐
       tions, invoking the most recent version of the system call provided
       by the kernel, and repacking the returned information  if  required
       for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat()
       system call and the kernel deals with a stat  structure  that  con‐
       tains fields of a sufficient size.

       The  underlying system call employed by the glibc fstatat() wrapper
       function is actually called fstatat64() or, on some  architectures,
       newfstatat().

EXAMPLES
       The following program calls lstat() and displays selected fields in
       the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <stdint.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%jx,%jx]\n",
                   (uintmax_t) major(sb.st_dev),
                   (uintmax_t) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ju\n", (uintmax_t) sb.st_ino);

           printf("Mode:                     %jo (octal)\n",
                   (uintmax_t) sb.st_mode);

           printf("Link count:               %ju\n", (uintmax_t) sb.st_nlink);
           printf("Ownership:                UID=%ju   GID=%ju\n",
                   (uintmax_t) sb.st_uid, (uintmax_t) sb.st_gid);

           printf("Preferred I/O block size: %jd bytes\n",
                   (intmax_t) sb.st_blksize);
           printf("File size:                %jd bytes\n",
                   (intmax_t) sb.st_size);
           printf("Blocks allocated:         %jd\n",
                   (intmax_t) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1),  stat(1),  access(2),   chmod(2),   chown(2),   readlink(2),
       statx(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-08-13                         STAT(2)
STAT(2)                  Linux Programmer's Manual                 STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions  return  information  about  a file, in the buffer
       pointed to by statbuf.  No permissions are required on the file it‐
       self,  but—in  the  case  of stat(), fstatat(), and lstat()—execute
       (search) permission is required on all of the directories in  path‐
       name that lead to the file.

       stat() and fstatat() retrieve information about the file pointed to
       by pathname; the differences for fstatat() are described below.

       lstat() is identical to stat(), except that if pathname is  a  sym‐
       bolic  link, then it returns information about the link itself, not
       the file that the link refers to.

       fstat() is identical to stat(), except that the  file  about  which
       information  is to be retrieved is specified by the file descriptor
       fd.

   The stat structure
       All of these system calls return a stat structure,  which  contains
       the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note:  the  order  of  fields in the stat structure varies somewhat
       across architectures.  In addition, the definition above  does  not
       show  the  padding bytes that may be present between some fields on
       various architectures.  Consult the glibc and kernel source code if
       you need to know the details.

       Note:  for  performance and simplicity reasons, different fields in
       the stat structure may contain state information from different mo‐
       ments  during  the  execution  of the system call.  For example, if
       st_mode or st_uid is changed by another process by calling chmod(2)
       or  chown(2), stat() might return the old st_mode together with the
       new st_uid, or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file  resides.
              (The major(3) and minor(3) macros may be useful to decompose
              the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and  mode.   See  inode(7)
              for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This  field describes the device that this file (inode) rep‐
              resents.

       st_size
              This field gives the size of the file (if it  is  a  regular
              file  or  a symbolic link) in bytes.  The size of a symbolic
              link is the length of the pathname it  contains,  without  a
              terminating null byte.

       st_blksize
              This  field  gives  the "preferred" block size for efficient
              filesystem I/O.

       st_blocks
              This field indicates the number of blocks allocated  to  the
              file,   in  512-byte  units.   (This  may  be  smaller  than
              st_size/512 when the file has holes.)

       st_atime
              This is the time of the last access of file data.

       st_mtime
              This is the time of last modification of file data.

       st_ctime
              This is the file's last status  change  timestamp  (time  of
              last change to the inode).

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for accessing
       file information which can still provide exactly  the  behavior  of
       each of stat(), lstat(), and fstat().

       If  the  pathname  given in pathname is relative, then it is inter‐
       preted relative to the directory referred to by the file descriptor
       dirfd (rather than relative to the current working directory of the
       calling process, as is done by stat() and lstat()  for  a  relative
       pathname).

       If  pathname  is  relative and dirfd is the special value AT_FDCWD,
       then pathname is interpreted relative to the current working direc‐
       tory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags  can  either  be  0,  or include one or more of the following
       flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred
              to  by dirfd (which may have been obtained using the open(2)
              O_PATH flag).  In this case, dirfd can refer to any type  of
              file, not just a directory, and the behavior of fstatat() is
              similar to that of fstat().  If dirfd is AT_FDCWD, the  call
              operates  on  the  current  working directory.  This flag is
              Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't automount the terminal ("basename") component of path‐
              name  if it is a directory that is an automount point.  This
              allows the caller to gather attributes of an automount point
              (rather  than  the  location  it  would mount).  Since Linux
              4.14, also don't instantiate a nonexistent name in an on-de‐
              mand  directory  such as used for automounter indirect maps.
              This flag has no effect if the mount point has already  been
              mounted over.

              Both  stat()  and  lstat() act as though AT_NO_AUTOMOUNT was
              set.

              The AT_NO_AUTOMOUNT can be used in tools that scan  directo‐
              ries  to  prevent  mass-automounting of a directory of auto‐
              mount points.

              This flag is Linux-specific; define  _GNU_SOURCE  to  obtain
              its definition.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is a symbolic link, do not dereference it: in‐
              stead  return  information  about  the  link  itself,   like
              lstat().    (By  default,  fstatat()  dereferences  symbolic
              links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and  errno
       is set appropriately.

ERRORS
       EACCES Search  permission  is  denied for one of the directories in
              the path prefix of pathname.  (See also path_resolution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links  encountered  while  traversing  the
              path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling sym‐
              bolic link.

       ENOENT pathname is an empty string and AT_EMPTY_PATH was not speci‐
              fied in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A  component  of the path prefix of pathname is not a direc‐
              tory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or
              number of blocks cannot be represented in, respectively, the
              types off_t, ino_t, or blkcnt_t.  This error can occur when,
              for  example,  an  application compiled on a 32-bit platform
              without -D_FILE_OFFSET_BITS=64 calls stat() on a file  whose
              size exceeds (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname  is  relative and dirfd is a file descriptor refer‐
              ring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support  was
       added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return
       valid information only in the st_size field and the  file  type  of
       the st_mode field of the stat structure.  POSIX.1-2008 tightens the
       specification, requiring lstat() to return valid information in all
       fields except the mode bits in st_mode.

       Use  of  the  st_blocks and st_blksize fields may be less portable.
       (They were introduced in BSD.  The interpretation  differs  between
       systems,  and  possibly  on a single system when NFS mounts are in‐
       volved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond  time‐
       stamp fields.  Instead, there were three timestamp fields—st_atime,
       st_mtime, and st_ctime—typed as  time_t  that  recorded  timestamps
       with one-second precision.

       Since kernel 2.5.48, the stat structure supports nanosecond resolu‐
       tion for the three file timestamp fields.   The  nanosecond  compo‐
       nents  of  each  timestamp  are  available  via  names  of the form
       st_atim.tv_nsec, if  suitable  feature  test  macros  are  defined.
       Nanosecond  timestamps  were  standardized  in  POSIX.1-2008,  and,
       starting with version 2.12, glibc exposes the nanosecond  component
       names  if  _POSIX_C_SOURCE  is  defined  with  the value 200809L or
       greater, or _XOPEN_SOURCE is defined with the value 700 or greater.
       Up  to and including glibc 2.19, the definitions of the nanoseconds
       components are also defined if _BSD_SOURCE or _SVID_SOURCE  is  de‐
       fined.   If none of the aforementioned macros are defined, then the
       nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over time, increases in the size of the stat structure have led  to
       three  successive  versions  of  stat(): sys_stat() (slot __NR_old‐
       stat),  sys_newstat()  (slot  __NR_stat),  and  sys_stat64()  (slot
       __NR_stat64)  on 32-bit platforms such as i386.  The first two ver‐
       sions were already present in  Linux  1.0  (albeit  with  different
       names); the last was added in Linux 2.4.  Similar remarks apply for
       fstat() and lstat().

       The kernel-internal versions of the stat structure  dealt  with  by
       the different versions are, respectively:

       __old_kernel_stat
              The  original  structure,  with rather narrow fields, and no
              padding.

       stat   Larger st_ino field and padding added to  various  parts  of
              the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to
              accommodate the Linux-2.4 expansion of UIDs and GIDs  to  32
              bits,  and various other enlarged fields and further padding
              in the structure.  (Various padding  bytes  were  eventually
              consumed  in Linux 2.6, with the advent of 32-bit device IDs
              and nanosecond components for the timestamp fields.)

       The glibc stat() wrapper function hides these details from applica‐
       tions, invoking the most recent version of the system call provided
       by the kernel, and repacking the returned information  if  required
       for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat()
       system call and the kernel deals with a stat  structure  that  con‐
       tains fields of a sufficient size.

       The  underlying system call employed by the glibc fstatat() wrapper
       function is actually called fstatat64() or, on some  architectures,
       newfstatat().

EXAMPLES
       The following program calls lstat() and displays selected fields in
       the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <stdint.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%jx,%jx]\n",
                   (uintmax_t) major(sb.st_dev),
                   (uintmax_t) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ju\n", (uintmax_t) sb.st_ino);

           printf("Mode:                     %jo (octal)\n",
                   (uintmax_t) sb.st_mode);

           printf("Link count:               %ju\n", (uintmax_t) sb.st_nlink);
           printf("Ownership:                UID=%ju   GID=%ju\n",
                   (uintmax_t) sb.st_uid, (uintmax_t) sb.st_gid);

           printf("Preferred I/O block size: %jd bytes\n",
                   (intmax_t) sb.st_blksize);
           printf("File size:                %jd bytes\n",
                   (intmax_t) sb.st_size);
           printf("Blocks allocated:         %jd\n",
                   (intmax_t) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1),  stat(1),  access(2),   chmod(2),   chown(2),   readlink(2),
       statx(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-08-13                         STAT(2)
STAT(2)                  Linux Programmer's Manual                 STAT(2)

NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <unistd.h>

       int stat(const char *pathname, struct stat *statbuf);
       int fstat(int fd, struct stat *statbuf);
       int lstat(const char *pathname, struct stat *statbuf);

       #include <fcntl.h>           /* Definition of AT_* constants */
       #include <sys/stat.h>

       int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
                   int flags);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       lstat():
           /* glibc 2.19 and earlier */ _BSD_SOURCE
               || /* Since glibc 2.20 */ _DEFAULT_SOURCE
               || _XOPEN_SOURCE >= 500
               || /* Since glibc 2.10: */ _POSIX_C_SOURCE >= 200112L

       fstatat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       These  functions  return  information  about  a file, in the buffer
       pointed to by statbuf.  No permissions are required on the file it‐
       self,  but—in  the  case  of stat(), fstatat(), and lstat()—execute
       (search) permission is required on all of the directories in  path‐
       name that lead to the file.

       stat() and fstatat() retrieve information about the file pointed to
       by pathname; the differences for fstatat() are described below.

       lstat() is identical to stat(), except that if pathname is  a  sym‐
       bolic  link, then it returns information about the link itself, not
       the file that the link refers to.

       fstat() is identical to stat(), except that the  file  about  which
       information  is to be retrieved is specified by the file descriptor
       fd.

   The stat structure
       All of these system calls return a stat structure,  which  contains
       the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

       Note:  the  order  of  fields in the stat structure varies somewhat
       across architectures.  In addition, the definition above  does  not
       show  the  padding bytes that may be present between some fields on
       various architectures.  Consult the glibc and kernel source code if
       you need to know the details.

       Note:  for  performance and simplicity reasons, different fields in
       the stat structure may contain state information from different mo‐
       ments  during  the  execution  of the system call.  For example, if
       st_mode or st_uid is changed by another process by calling chmod(2)
       or  chown(2), stat() might return the old st_mode together with the
       new st_uid, or the old st_uid together with the new st_mode.

       The fields in the stat structure are as follows:

       st_dev This field describes the device on which this file  resides.
              (The major(3) and minor(3) macros may be useful to decompose
              the device ID in this field.)

       st_ino This field contains the file's inode number.

       st_mode
              This field contains the file type and  mode.   See  inode(7)
              for further information.

       st_nlink
              This field contains the number of hard links to the file.

       st_uid This field contains the user ID of the owner of the file.

       st_gid This field contains the ID of the group owner of the file.

       st_rdev
              This  field describes the device that this file (inode) rep‐
              resents.

       st_size
              This field gives the size of the file (if it  is  a  regular
              file  or  a symbolic link) in bytes.  The size of a symbolic
              link is the length of the pathname it  contains,  without  a
              terminating null byte.

       st_blksize
              This  field  gives  the "preferred" block size for efficient
              filesystem I/O.

       st_blocks
              This field indicates the number of blocks allocated  to  the
              file,   in  512-byte  units.   (This  may  be  smaller  than
              st_size/512 when the file has holes.)

       st_atime
              This is the time of the last access of file data.

       st_mtime
              This is the time of last modification of file data.

       st_ctime
              This is the file's last status  change  timestamp  (time  of
              last change to the inode).

       For further information on the above fields, see inode(7).

   fstatat()
       The fstatat() system call is a more general interface for accessing
       file information which can still provide exactly  the  behavior  of
       each of stat(), lstat(), and fstat().

       If  the  pathname  given in pathname is relative, then it is inter‐
       preted relative to the directory referred to by the file descriptor
       dirfd (rather than relative to the current working directory of the
       calling process, as is done by stat() and lstat()  for  a  relative
       pathname).

       If  pathname  is  relative and dirfd is the special value AT_FDCWD,
       then pathname is interpreted relative to the current working direc‐
       tory of the calling process (like stat() and lstat()).

       If pathname is absolute, then dirfd is ignored.

       flags  can  either  be  0,  or include one or more of the following
       flags ORed:

       AT_EMPTY_PATH (since Linux 2.6.39)
              If pathname is an empty string, operate on the file referred
              to  by dirfd (which may have been obtained using the open(2)
              O_PATH flag).  In this case, dirfd can refer to any type  of
              file, not just a directory, and the behavior of fstatat() is
              similar to that of fstat().  If dirfd is AT_FDCWD, the  call
              operates  on  the  current  working directory.  This flag is
              Linux-specific; define _GNU_SOURCE to obtain its definition.

       AT_NO_AUTOMOUNT (since Linux 2.6.38)
              Don't automount the terminal ("basename") component of path‐
              name  if it is a directory that is an automount point.  This
              allows the caller to gather attributes of an automount point
              (rather  than  the  location  it  would mount).  Since Linux
              4.14, also don't instantiate a nonexistent name in an on-de‐
              mand  directory  such as used for automounter indirect maps.
              This flag has no effect if the mount point has already  been
              mounted over.

              Both  stat()  and  lstat() act as though AT_NO_AUTOMOUNT was
              set.

              The AT_NO_AUTOMOUNT can be used in tools that scan  directo‐
              ries  to  prevent  mass-automounting of a directory of auto‐
              mount points.

              This flag is Linux-specific; define  _GNU_SOURCE  to  obtain
              its definition.

       AT_SYMLINK_NOFOLLOW
              If  pathname  is a symbolic link, do not dereference it: in‐
              stead  return  information  about  the  link  itself,   like
              lstat().    (By  default,  fstatat()  dereferences  symbolic
              links, like stat().)

       See openat(2) for an explanation of the need for fstatat().

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and  errno
       is set appropriately.

ERRORS
       EACCES Search  permission  is  denied for one of the directories in
              the path prefix of pathname.  (See also path_resolution(7).)

       EBADF  fd is not a valid open file descriptor.

       EFAULT Bad address.

       ELOOP  Too many symbolic links  encountered  while  traversing  the
              path.

       ENAMETOOLONG
              pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling sym‐
              bolic link.

       ENOENT pathname is an empty string and AT_EMPTY_PATH was not speci‐
              fied in flags.

       ENOMEM Out of memory (i.e., kernel memory).

       ENOTDIR
              A  component  of the path prefix of pathname is not a direc‐
              tory.

       EOVERFLOW
              pathname or fd refers to a file whose size, inode number, or
              number of blocks cannot be represented in, respectively, the
              types off_t, ino_t, or blkcnt_t.  This error can occur when,
              for  example,  an  application compiled on a 32-bit platform
              without -D_FILE_OFFSET_BITS=64 calls stat() on a file  whose
              size exceeds (1<<31)-1 bytes.

       The following additional errors can occur for fstatat():

       EBADF  dirfd is not a valid file descriptor.

       EINVAL Invalid flag specified in flags.

       ENOTDIR
              pathname  is  relative and dirfd is a file descriptor refer‐
              ring to a file other than a directory.

VERSIONS
       fstatat() was added to Linux in kernel 2.6.16; library support  was
       added to glibc in version 2.4.

CONFORMING TO
       stat(), fstat(), lstat(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.

       fstatat(): POSIX.1-2008.

       According  to  POSIX.1-2001, lstat() on a symbolic link need return
       valid information only in the st_size field and the  file  type  of
       the st_mode field of the stat structure.  POSIX.1-2008 tightens the
       specification, requiring lstat() to return valid information in all
       fields except the mode bits in st_mode.

       Use  of  the  st_blocks and st_blksize fields may be less portable.
       (They were introduced in BSD.  The interpretation  differs  between
       systems,  and  possibly  on a single system when NFS mounts are in‐
       volved.)

NOTES
   Timestamp fields
       Older kernels and older standards did not support nanosecond  time‐
       stamp fields.  Instead, there were three timestamp fields—st_atime,
       st_mtime, and st_ctime—typed as  time_t  that  recorded  timestamps
       with one-second precision.

       Since kernel 2.5.48, the stat structure supports nanosecond resolu‐
       tion for the three file timestamp fields.   The  nanosecond  compo‐
       nents  of  each  timestamp  are  available  via  names  of the form
       st_atim.tv_nsec, if  suitable  feature  test  macros  are  defined.
       Nanosecond  timestamps  were  standardized  in  POSIX.1-2008,  and,
       starting with version 2.12, glibc exposes the nanosecond  component
       names  if  _POSIX_C_SOURCE  is  defined  with  the value 200809L or
       greater, or _XOPEN_SOURCE is defined with the value 700 or greater.
       Up  to and including glibc 2.19, the definitions of the nanoseconds
       components are also defined if _BSD_SOURCE or _SVID_SOURCE  is  de‐
       fined.   If none of the aforementioned macros are defined, then the
       nanosecond values are exposed with names of the form st_atimensec.

   C library/kernel differences
       Over time, increases in the size of the stat structure have led  to
       three  successive  versions  of  stat(): sys_stat() (slot __NR_old‐
       stat),  sys_newstat()  (slot  __NR_stat),  and  sys_stat64()  (slot
       __NR_stat64)  on 32-bit platforms such as i386.  The first two ver‐
       sions were already present in  Linux  1.0  (albeit  with  different
       names); the last was added in Linux 2.4.  Similar remarks apply for
       fstat() and lstat().

       The kernel-internal versions of the stat structure  dealt  with  by
       the different versions are, respectively:

       __old_kernel_stat
              The  original  structure,  with rather narrow fields, and no
              padding.

       stat   Larger st_ino field and padding added to  various  parts  of
              the structure to allow for future expansion.

       stat64 Even larger st_ino field, larger st_uid and st_gid fields to
              accommodate the Linux-2.4 expansion of UIDs and GIDs  to  32
              bits,  and various other enlarged fields and further padding
              in the structure.  (Various padding  bytes  were  eventually
              consumed  in Linux 2.6, with the advent of 32-bit device IDs
              and nanosecond components for the timestamp fields.)

       The glibc stat() wrapper function hides these details from applica‐
       tions, invoking the most recent version of the system call provided
       by the kernel, and repacking the returned information  if  required
       for old binaries.

       On modern 64-bit systems, life is simpler: there is a single stat()
       system call and the kernel deals with a stat  structure  that  con‐
       tains fields of a sufficient size.

       The  underlying system call employed by the glibc fstatat() wrapper
       function is actually called fstatat64() or, on some  architectures,
       newfstatat().

EXAMPLES
       The following program calls lstat() and displays selected fields in
       the returned stat structure.

       #include <sys/types.h>
       #include <sys/stat.h>
       #include <stdint.h>
       #include <time.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <sys/sysmacros.h>

       int
       main(int argc, char *argv[])
       {
           struct stat sb;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s <pathname>\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           if (lstat(argv[1], &sb) == -1) {
               perror("lstat");
               exit(EXIT_FAILURE);
           }

           printf("ID of containing device:  [%jx,%jx]\n",
                   (uintmax_t) major(sb.st_dev),
                   (uintmax_t) minor(sb.st_dev));

           printf("File type:                ");

           switch (sb.st_mode & S_IFMT) {
           case S_IFBLK:  printf("block device\n");            break;
           case S_IFCHR:  printf("character device\n");        break;
           case S_IFDIR:  printf("directory\n");               break;
           case S_IFIFO:  printf("FIFO/pipe\n");               break;
           case S_IFLNK:  printf("symlink\n");                 break;
           case S_IFREG:  printf("regular file\n");            break;
           case S_IFSOCK: printf("socket\n");                  break;
           default:       printf("unknown?\n");                break;
           }

           printf("I-node number:            %ju\n", (uintmax_t) sb.st_ino);

           printf("Mode:                     %jo (octal)\n",
                   (uintmax_t) sb.st_mode);

           printf("Link count:               %ju\n", (uintmax_t) sb.st_nlink);
           printf("Ownership:                UID=%ju   GID=%ju\n",
                   (uintmax_t) sb.st_uid, (uintmax_t) sb.st_gid);

           printf("Preferred I/O block size: %jd bytes\n",
                   (intmax_t) sb.st_blksize);
           printf("File size:                %jd bytes\n",
                   (intmax_t) sb.st_size);
           printf("Blocks allocated:         %jd\n",
                   (intmax_t) sb.st_blocks);

           printf("Last status change:       %s", ctime(&sb.st_ctime));
           printf("Last file access:         %s", ctime(&sb.st_atime));
           printf("Last file modification:   %s", ctime(&sb.st_mtime));

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       ls(1),  stat(1),  access(2),   chmod(2),   chown(2),   readlink(2),
       statx(2), utime(2), capabilities(7), inode(7), symlink(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-08-13                         STAT(2)
STRTOK(3)                Linux Programmer's Manual               STRTOK(3)

NAME
       strtok, strtok_r - extract tokens from strings

SYNOPSIS
       #include <string.h>

       char *strtok(char *str, const char *delim);

       char *strtok_r(char *str, const char *delim, char **saveptr);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       strtok_r(): _POSIX_C_SOURCE
           || /* Glibc versions <= 2.19: */ _BSD_SOURCE || _SVID_SOURCE

DESCRIPTION
       The  strtok()  function  breaks a string into a sequence of zero or
       more nonempty tokens.  On the first call to strtok(), the string to
       be parsed should be specified in str.  In each subsequent call that
       should parse the same string, str must be NULL.

       The delim argument specifies a set of bytes that delimit the tokens
       in  the parsed string.  The caller may specify different strings in
       delim in successive calls that parse the same string.

       Each call to strtok() returns a pointer to a null-terminated string
       containing the next token.  This string does not include the delim‐
       iting byte.  If no more tokens are found, strtok() returns NULL.

       A sequence of calls to strtok() that operate  on  the  same  string
       maintains  a  pointer that determines the point from which to start
       searching for the next token.  The first call to strtok() sets this
       pointer to point to the first byte of the string.  The start of the
       next token is determined by scanning forward for the next nondelim‐
       iter  byte  in  str.   If  such a byte is found, it is taken as the
       start of the next token.  If no such byte is found, then there  are
       no more tokens, and strtok() returns NULL.  (A string that is empty
       or that contains only delimiters will thus cause strtok() to return
       NULL on the first call.)

       The end of each token is found by scanning forward until either the
       next delimiter byte is found or until  the  terminating  null  byte
       ('\0')  is  encountered.  If a delimiter byte is found, it is over‐
       written with a null byte to terminate the current token,  and  str‐
       tok()  saves  a pointer to the following byte; that pointer will be
       used as the starting point when searching for the next  token.   In
       this case, strtok() returns a pointer to the start of the found to‐
       ken.

       From the above description, it follows that a sequence  of  two  or
       more  contiguous delimiter bytes in the parsed string is considered
       to be a single delimiter, and that delimiter bytes at the start  or
       end  of  the  string  are ignored.  Put another way: the tokens re‐
       turned by strtok() are always nonempty strings.  Thus, for example,
       given  the  string  "aaa;;bbb,",  successive calls to strtok() that
       specify the delimiter string ";," would return  the  strings  "aaa"
       and "bbb", and then a null pointer.

       The  strtok_r()  function  is a reentrant version of strtok().  The
       saveptr argument is a pointer to a char * variable that is used in‐
       ternally by strtok_r() in order to maintain context between succes‐
       sive calls that parse the same string.

       On the first call to strtok_r(), str should point to the string  to
       be  parsed,  and  the value of *saveptr is ignored (but see NOTES).
       In subsequent calls, str should be NULL, and saveptr (and the  buf‐
       fer that it points to) should be unchanged since the previous call.

       Different  strings  may  be  parsed concurrently using sequences of
       calls to strtok_r() that specify different saveptr arguments.

RETURN VALUE
       The strtok() and strtok_r() functions return a pointer to the  next
       token, or NULL if there are no more tokens.

ATTRIBUTES
       For  an  explanation  of  the  terms  used in this section, see at‐
       tributes(7).

       ┌───────────┬───────────────┬───────────────────────┐
       │Interface  │ Attribute     │ Value                 │
       ├───────────┼───────────────┼───────────────────────┤
       │strtok()   │ Thread safety │ MT-Unsafe race:strtok │
       ├───────────┼───────────────┼───────────────────────┤
       │strtok_r() │ Thread safety │ MT-Safe               │
       └───────────┴───────────────┴───────────────────────┘
CONFORMING TO
       strtok()
              POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

       strtok_r()
              POSIX.1-2001, POSIX.1-2008.

NOTES
       On some implementations, *saveptr is required to  be  NULL  on  the
       first call to strtok_r() that is being used to parse str.

BUGS
       Be  cautious  when using these functions.  If you do use them, note
       that:

       * These functions modify their first argument.

       * These functions cannot be used on constant strings.

       * The identity of the delimiting byte is lost.

       * The strtok() function uses a static buffer while parsing, so it's
         not thread safe.  Use strtok_r() if this matters to you.

EXAMPLES
       The program below uses nested loops that employ strtok_r() to break
       a string into a two-level hierarchy of tokens.  The first  command-
       line  argument specifies the string to be parsed.  The second argu‐
       ment specifies the delimiter byte(s) to be used  to  separate  that
       string  into  "major" tokens.  The third argument specifies the de‐
       limiter byte(s) to be used to  separate  the  "major"  tokens  into
       subtokens.

       An example of the output produced by this program is the following:

           $ ./a.out 'a/bbb///cc;xxx:yyy:' ':;' '/'
           1: a/bbb///cc
                    --> a
                    --> bbb
                    --> cc
           2: xxx
                    --> xxx
           3: yyy
                    --> yyy

   Program source

       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>

       int
       main(int argc, char *argv[])
       {
           char *str1, *str2, *token, *subtoken;
           char *saveptr1, *saveptr2;

           if (argc != 4) {
               fprintf(stderr, "Usage: %s string delim subdelim\n",
                       argv[0]);
               exit(EXIT_FAILURE);
           }

           for (int j = 1, str1 = argv[1]; ; j++, str1 = NULL) {
               token = strtok_r(str1, argv[2], &saveptr1);
               if (token == NULL)
                   break;
               printf("%d: %s\n", j, token);

               for (str2 = token; ; str2 = NULL) {
                   subtoken = strtok_r(str2, argv[3], &saveptr2);
                   if (subtoken == NULL)
                       break;
                   printf(" --> %s\n", subtoken);
               }
           }

           exit(EXIT_SUCCESS);
       }

       Another  example  program  using  strtok()  can  be found in getad‐
       drinfo_a(3).

SEE ALSO
       index(3), memchr(3), rindex(3), strchr(3),  string(3),  strpbrk(3),
       strsep(3), strspn(3), strstr(3), wcstok(3)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

GNU                             2020-11-01                       STRTOK(3)
WAIT(2)                  Linux Programmer's Manual                 WAIT(2)

NAME
       wait, waitpid, waitid - wait for process to change state

SYNOPSIS
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t wait(int *wstatus);

       pid_t waitpid(pid_t pid, int *wstatus, int options);

       int  waitid(idtype_t  idtype,  id_t  id,  siginfo_t *infop, int op‐
       tions);
                       /* This is the glibc and POSIX interface; see
                          NOTES for information on the raw system call. */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       waitid():
           Since glibc 2.26: _XOPEN_SOURCE >= 500 ||
               _POSIX_C_SOURCE >= 200809L
           Glibc 2.25 and earlier:
               _XOPEN_SOURCE
                   || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       All of these system calls are used to wait for state changes  in  a
       child  of  the  calling  process,  and obtain information about the
       child whose state has changed.  A state change is considered to be:
       the  child  terminated;  the  child was stopped by a signal; or the
       child was resumed by a signal.  In the case of a terminated  child,
       performing  a wait allows the system to release the resources asso‐
       ciated with the child; if a wait is not performed, then the  termi‐
       nated child remains in a "zombie" state (see NOTES below).

       If a child has already changed state, then these calls return imme‐
       diately.  Otherwise, they block until either a child changes  state
       or a signal handler interrupts the call (assuming that system calls
       are not automatically restarted using the SA_RESTART flag of sigac‐
       tion(2)).   In  the remainder of this page, a child whose state has
       changed and which has not yet been waited upon by one of these sys‐
       tem calls is termed waitable.

   wait() and waitpid()
       The wait() system call suspends execution of the calling thread un‐
       til one of its children terminates.   The  call  wait(&wstatus)  is
       equivalent to:

           waitpid(-1, &wstatus, 0);

       The  waitpid() system call suspends execution of the calling thread
       until a child specified by pid argument has changed state.  By  de‐
       fault,  waitpid()  waits only for terminated children, but this be‐
       havior is modifiable via the options argument, as described below.

       The value of pid can be:

       < -1   meaning wait for any child process whose process group ID is
              equal to the absolute value of pid.

       -1     meaning wait for any child process.

       0      meaning wait for any child process whose process group ID is
              equal to that of the calling process at the time of the call
              to waitpid().

       > 0    meaning  wait for the child whose process ID is equal to the
              value of pid.

       The value of options is an OR of zero or more of the following con‐
       stants:

       WNOHANG
              return immediately if no child has exited.

       WUNTRACED
              also  return  if  a  child  has  stopped (but not traced via
              ptrace(2)).  Status for traced children which  have  stopped
              is provided even if this option is not specified.

       WCONTINUED (since Linux 2.6.10)
              also  return if a stopped child has been resumed by delivery
              of SIGCONT.

       (For Linux-only options, see below.)

       If wstatus is not NULL, wait() and waitpid() store status  informa‐
       tion  in the int to which it points.  This integer can be inspected
       with the following macros (which take the integer itself as an  ar‐
       gument, not a pointer to it, as is done in wait() and waitpid()!):

       WIFEXITED(wstatus)
              returns  true  if the child terminated normally, that is, by
              calling exit(3) or _exit(2), or by returning from main().

       WEXITSTATUS(wstatus)
              returns the exit status of the child.  This consists of  the
              least  significant  8  bits  of the status argument that the
              child specified in a call to exit(3) or _exit(2) or  as  the
              argument  for  a  return  statement  in  main().  This macro
              should be employed only if WIFEXITED returned true.

       WIFSIGNALED(wstatus)
              returns true if the child process was terminated by  a  sig‐
              nal.

       WTERMSIG(wstatus)
              returns  the  number  of  the  signal  that caused the child
              process to terminate.  This macro should be employed only if
              WIFSIGNALED returned true.

       WCOREDUMP(wstatus)
              returns  true  if  the  child  produced  a  core  dump  (see
              core(5)).  This macro should be employed only if WIFSIGNALED
              returned true.

              This  macro  is  not  specified  in  POSIX.1-2001 and is not
              available on some UNIX implementations (e.g.,  AIX,  SunOS).
              Therefore,  enclose its use inside #ifdef WCOREDUMP ... #en‐
              dif.

       WIFSTOPPED(wstatus)
              returns true if the child process was stopped by delivery of
              a  signal;  this is possible only if the call was done using
              WUNTRACED or when the child is being traced (see ptrace(2)).

       WSTOPSIG(wstatus)
              returns the number of the signal which caused the  child  to
              stop.   This macro should be employed only if WIFSTOPPED re‐
              turned true.

       WIFCONTINUED(wstatus)
              (since Linux 2.6.10) returns true if the child  process  was
              resumed by delivery of SIGCONT.

   waitid()
       The  waitid()  system  call  (available since Linux 2.6.9) provides
       more precise control over which child state changes to wait for.

       The idtype and id arguments select the child(ren) to wait  for,  as
       follows:

       idtype == P_PID
              Wait for the child whose process ID matches id.

       idtype == P_PIDFD (since Linux 5.4)
              Wait  for  the  child referred to by the PID file descriptor
              specified in id.  (See pidfd_open(2) for further information
              on PID file descriptors.)

       idtype == P_PGID
              Wait for any child whose process group ID matches id.  Since
              Linux 5.4, if id is zero, then wait for any child that is in
              the  same process group as the caller's process group at the
              time of the call.

       idtype == P_ALL
              Wait for any child; id is ignored.

       The child state changes to wait for are specified by ORing  one  or
       more of the following flags in options:

       WEXITED
              Wait for children that have terminated.

       WSTOPPED
              Wait  for  children  that have been stopped by delivery of a
              signal.

       WCONTINUED
              Wait for (previously stopped) children that  have  been  re‐
              sumed by delivery of SIGCONT.

       The following flags may additionally be ORed in options:

       WNOHANG
              As for waitpid().

       WNOWAIT
              Leave  the  child in a waitable state; a later wait call can
              be used to again retrieve the child status information.

       Upon successful return, waitid() fills in the following  fields  of
       the siginfo_t structure pointed to by infop:

       si_pid The process ID of the child.

       si_uid The  real  user  ID of the child.  (This field is not set on
              most other implementations.)

       si_signo
              Always set to SIGCHLD.

       si_status
              Either the exit status of the child, as  given  to  _exit(2)
              (or  exit(3)), or the signal that caused the child to termi‐
              nate, stop, or continue.  The si_code field can be  used  to
              determine how to interpret this field.

       si_code
              Set   to   one   of:  CLD_EXITED  (child  called  _exit(2));
              CLD_KILLED  (child  killed  by  signal);  CLD_DUMPED  (child
              killed  by  signal,  and  dumped  core);  CLD_STOPPED (child
              stopped by signal); CLD_TRAPPED (traced child has  trapped);
              or CLD_CONTINUED (child continued by SIGCONT).

       If WNOHANG was specified in options and there were no children in a
       waitable state, then waitid() returns 0 immediately and  the  state
       of  the  siginfo_t structure pointed to by infop depends on the im‐
       plementation.  To (portably) distinguish this case from that  where
       a  child  was in a waitable state, zero out the si_pid field before
       the call and check for a nonzero value in this field after the call
       returns.

       POSIX.1-2008  Technical  Corrigendum  1 (2013) adds the requirement
       that when WNOHANG is specified in options and there were  no  chil‐
       dren  in a waitable state, then waitid() should zero out the si_pid
       and si_signo fields of the structure.  On Linux and other implemen‐
       tations  that  adhere  to  this requirement, it is not necessary to
       zero out the si_pid field before calling  waitid().   However,  not
       all implementations follow the POSIX.1 specification on this point.

RETURN VALUE
       wait(): on success, returns the process ID of the terminated child;
       on error, -1 is returned.

       waitpid(): on success, returns the process ID of  the  child  whose
       state  has  changed;  if  WNOHANG  was  specified  and  one or more
       child(ren) specified by pid exist, but have not yet changed  state,
       then 0 is returned.  On error, -1 is returned.

       waitid():  returns  0 on success or if WNOHANG was specified and no
       child(ren) specified by id has yet changed state; on error,  -1  is
       returned.

       Each  of these calls sets errno to an appropriate value in the case
       of an error.

ERRORS
       ECHILD (for wait()) The calling process does not have any unwaited-
              for children.

       ECHILD (for  waitpid()  or  waitid())  The process specified by pid
              (waitpid()) or idtype and id (waitid()) does not exist or is
              not  a  child  of the calling process.  (This can happen for
              one's own child if the action for SIGCHLD is set to SIG_IGN.
              See also the Linux Notes section about threads.)

       EINTR  WNOHANG was not set and an unblocked signal or a SIGCHLD was
              caught; see signal(7).

       EINVAL The options argument was invalid.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
       A child that terminates, but has not  been  waited  for  becomes  a
       "zombie".   The kernel maintains a minimal set of information about
       the zombie process (PID, termination status, resource usage  infor‐
       mation) in order to allow the parent to later perform a wait to ob‐
       tain information about the child.  As long as a zombie is  not  re‐
       moved  from  the  system  via a wait, it will consume a slot in the
       kernel process table, and if this table fills, it will not be  pos‐
       sible to create further processes.  If a parent process terminates,
       then its "zombie" children (if any) are adopted by init(1), (or  by
       the  nearest  "subreaper" process as defined through the use of the
       prctl(2) PR_SET_CHILD_SUBREAPER operation);  init(1)  automatically
       performs a wait to remove the zombies.

       POSIX.1-2001 specifies that if the disposition of SIGCHLD is set to
       SIG_IGN or the SA_NOCLDWAIT flag is set  for  SIGCHLD  (see  sigac‐
       tion(2)),  then children that terminate do not become zombies and a
       call to wait() or waitpid() will block until all children have ter‐
       minated,  and  then  fail  with errno set to ECHILD.  (The original
       POSIX standard left the behavior of setting SIGCHLD to SIG_IGN  un‐
       specified.   Note  that  even  though  the  default  disposition of
       SIGCHLD is "ignore", explicitly setting the disposition to  SIG_IGN
       results in different treatment of zombie process children.)

       Linux  2.6  conforms to the POSIX requirements.  However, Linux 2.4
       (and earlier) does not: if a wait() or waitpid() call is made while
       SIGCHLD  is  being ignored, the call behaves just as though SIGCHLD
       were not being ignored, that is, the call  blocks  until  the  next
       child terminates and then returns the process ID and status of that
       child.

   Linux notes
       In the Linux kernel, a kernel-scheduled thread is  not  a  distinct
       construct  from  a  process.  Instead, a thread is simply a process
       that is created using the Linux-unique clone(2) system call;  other
       routines  such  as  the  portable pthread_create(3) call are imple‐
       mented using clone(2).  Before Linux 2.4, a thread was just a  spe‐
       cial  case  of a process, and as a consequence one thread could not
       wait on the children of another thread, even when  the  latter  be‐
       longs  to  the  same  thread group.  However, POSIX prescribes such
       functionality, and since Linux 2.4 a thread  can,  and  by  default
       will, wait on children of other threads in the same thread group.

       The following Linux-specific options are for use with children cre‐
       ated using clone(2); they can also, since Linux 4.7, be  used  with
       waitid():

       __WCLONE
              Wait  for  "clone" children only.  If omitted, then wait for
              "non-clone" children only.  (A "clone" child  is  one  which
              delivers  no  signal,  or a signal other than SIGCHLD to its
              parent upon termination.)  This option is ignored if  __WALL
              is also specified.

       __WALL (since Linux 2.4)
              Wait  for all children, regardless of type ("clone" or "non-
              clone").

       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads in the same thread
              group.  This was the default before Linux 2.4.

       Since  Linux  4.7,  the __WALL flag is automatically implied if the
       child is being ptraced.

   C library/kernel differences
       wait() is actually a library function that  (in  glibc)  is  imple‐
       mented as a call to wait4(2).

       On  some architectures, there is no waitpid() system call; instead,
       this interface is implemented via a C library wrapper function that
       calls wait4(2).

       The raw waitid() system call takes a fifth argument, of type struct
       rusage *.  If this argument is non-NULL, then it is used to  return
       resource  usage  information about the child, in the same manner as
       wait4(2).  See getrusage(2) for details.

BUGS
       According to POSIX.1-2008, an application calling waitid() must en‐
       sure that infop points to a siginfo_t structure (i.e., that it is a
       non-null pointer).  On Linux, if infop is NULL, waitid()  succeeds,
       and  returns  the process ID of the waited-for child.  Applications
       should avoid relying on this inconsistent, nonstandard, and  unnec‐
       essary feature.

EXAMPLES
       The  following  program  demonstrates  the use of fork(2) and wait‐
       pid().  The program creates a child process.   If  no  command-line
       argument  is  supplied  to the program, then the child suspends its
       execution using pause(2), to allow the user to send signals to  the
       child.  Otherwise, if a command-line argument is supplied, then the
       child exits immediately, using the integer supplied on the  command
       line  as  the exit status.  The parent process executes a loop that
       monitors the child using waitpid(), and uses the  W*()  macros  de‐
       scribed above to analyze the wait status value.

       The following shell session demonstrates the use of the program:

           $ ./a.out &
           Child PID is 32360
           [1] 32359
           $ kill -STOP 32360
           stopped by signal 19
           $ kill -CONT 32360
           continued
           $ kill -TERM 32360
           killed by signal 15
           [1]+  Done                    ./a.out
           $

   Program source

       #include <sys/wait.h>
       #include <stdint.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <stdio.h>

       int
       main(int argc, char *argv[])
       {
           pid_t cpid, w;
           int wstatus;

           cpid = fork();
           if (cpid == -1) {
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (cpid == 0) {            /* Code executed by child */
               printf("Child PID is %jd\n", (intmax_t) getpid());
               if (argc == 1)
                   pause();                    /* Wait for signals */
               _exit(atoi(argv[1]));

           } else {                    /* Code executed by parent */
               do {
                   w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);
                   if (w == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(wstatus)) {
                       printf("exited, status=%d\n", WEXITSTATUS(wstatus));
                   } else if (WIFSIGNALED(wstatus)) {
                       printf("killed by signal %d\n", WTERMSIG(wstatus));
                   } else if (WIFSTOPPED(wstatus)) {
                       printf("stopped by signal %d\n", WSTOPSIG(wstatus));
                   } else if (WIFCONTINUED(wstatus)) {
                       printf("continued\n");
                   }
               } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));
               exit(EXIT_SUCCESS);
           }
       }

SEE ALSO
       _exit(2), clone(2), fork(2), kill(2), ptrace(2), sigaction(2), sig‐
       nal(2), wait4(2), pthread_create(3), core(5), credentials(7),  sig‐
       nal(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-11-01                         WAIT(2)
WAIT(2)                  Linux Programmer's Manual                 WAIT(2)

NAME
       wait, waitpid, waitid - wait for process to change state

SYNOPSIS
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t wait(int *wstatus);

       pid_t waitpid(pid_t pid, int *wstatus, int options);

       int  waitid(idtype_t  idtype,  id_t  id,  siginfo_t *infop, int op‐
       tions);
                       /* This is the glibc and POSIX interface; see
                          NOTES for information on the raw system call. */

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       waitid():
           Since glibc 2.26: _XOPEN_SOURCE >= 500 ||
               _POSIX_C_SOURCE >= 200809L
           Glibc 2.25 and earlier:
               _XOPEN_SOURCE
                   || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
                   || /* Glibc versions <= 2.19: */ _BSD_SOURCE

DESCRIPTION
       All of these system calls are used to wait for state changes  in  a
       child  of  the  calling  process,  and obtain information about the
       child whose state has changed.  A state change is considered to be:
       the  child  terminated;  the  child was stopped by a signal; or the
       child was resumed by a signal.  In the case of a terminated  child,
       performing  a wait allows the system to release the resources asso‐
       ciated with the child; if a wait is not performed, then the  termi‐
       nated child remains in a "zombie" state (see NOTES below).

       If a child has already changed state, then these calls return imme‐
       diately.  Otherwise, they block until either a child changes  state
       or a signal handler interrupts the call (assuming that system calls
       are not automatically restarted using the SA_RESTART flag of sigac‐
       tion(2)).   In  the remainder of this page, a child whose state has
       changed and which has not yet been waited upon by one of these sys‐
       tem calls is termed waitable.

   wait() and waitpid()
       The wait() system call suspends execution of the calling thread un‐
       til one of its children terminates.   The  call  wait(&wstatus)  is
       equivalent to:

           waitpid(-1, &wstatus, 0);

       The  waitpid() system call suspends execution of the calling thread
       until a child specified by pid argument has changed state.  By  de‐
       fault,  waitpid()  waits only for terminated children, but this be‐
       havior is modifiable via the options argument, as described below.

       The value of pid can be:

       < -1   meaning wait for any child process whose process group ID is
              equal to the absolute value of pid.

       -1     meaning wait for any child process.

       0      meaning wait for any child process whose process group ID is
              equal to that of the calling process at the time of the call
              to waitpid().

       > 0    meaning  wait for the child whose process ID is equal to the
              value of pid.

       The value of options is an OR of zero or more of the following con‐
       stants:

       WNOHANG
              return immediately if no child has exited.

       WUNTRACED
              also  return  if  a  child  has  stopped (but not traced via
              ptrace(2)).  Status for traced children which  have  stopped
              is provided even if this option is not specified.

       WCONTINUED (since Linux 2.6.10)
              also  return if a stopped child has been resumed by delivery
              of SIGCONT.

       (For Linux-only options, see below.)

       If wstatus is not NULL, wait() and waitpid() store status  informa‐
       tion  in the int to which it points.  This integer can be inspected
       with the following macros (which take the integer itself as an  ar‐
       gument, not a pointer to it, as is done in wait() and waitpid()!):

       WIFEXITED(wstatus)
              returns  true  if the child terminated normally, that is, by
              calling exit(3) or _exit(2), or by returning from main().

       WEXITSTATUS(wstatus)
              returns the exit status of the child.  This consists of  the
              least  significant  8  bits  of the status argument that the
              child specified in a call to exit(3) or _exit(2) or  as  the
              argument  for  a  return  statement  in  main().  This macro
              should be employed only if WIFEXITED returned true.

       WIFSIGNALED(wstatus)
              returns true if the child process was terminated by  a  sig‐
              nal.

       WTERMSIG(wstatus)
              returns  the  number  of  the  signal  that caused the child
              process to terminate.  This macro should be employed only if
              WIFSIGNALED returned true.

       WCOREDUMP(wstatus)
              returns  true  if  the  child  produced  a  core  dump  (see
              core(5)).  This macro should be employed only if WIFSIGNALED
              returned true.

              This  macro  is  not  specified  in  POSIX.1-2001 and is not
              available on some UNIX implementations (e.g.,  AIX,  SunOS).
              Therefore,  enclose its use inside #ifdef WCOREDUMP ... #en‐
              dif.

       WIFSTOPPED(wstatus)
              returns true if the child process was stopped by delivery of
              a  signal;  this is possible only if the call was done using
              WUNTRACED or when the child is being traced (see ptrace(2)).

       WSTOPSIG(wstatus)
              returns the number of the signal which caused the  child  to
              stop.   This macro should be employed only if WIFSTOPPED re‐
              turned true.

       WIFCONTINUED(wstatus)
              (since Linux 2.6.10) returns true if the child  process  was
              resumed by delivery of SIGCONT.

   waitid()
       The  waitid()  system  call  (available since Linux 2.6.9) provides
       more precise control over which child state changes to wait for.

       The idtype and id arguments select the child(ren) to wait  for,  as
       follows:

       idtype == P_PID
              Wait for the child whose process ID matches id.

       idtype == P_PIDFD (since Linux 5.4)
              Wait  for  the  child referred to by the PID file descriptor
              specified in id.  (See pidfd_open(2) for further information
              on PID file descriptors.)

       idtype == P_PGID
              Wait for any child whose process group ID matches id.  Since
              Linux 5.4, if id is zero, then wait for any child that is in
              the  same process group as the caller's process group at the
              time of the call.

       idtype == P_ALL
              Wait for any child; id is ignored.

       The child state changes to wait for are specified by ORing  one  or
       more of the following flags in options:

       WEXITED
              Wait for children that have terminated.

       WSTOPPED
              Wait  for  children  that have been stopped by delivery of a
              signal.

       WCONTINUED
              Wait for (previously stopped) children that  have  been  re‐
              sumed by delivery of SIGCONT.

       The following flags may additionally be ORed in options:

       WNOHANG
              As for waitpid().

       WNOWAIT
              Leave  the  child in a waitable state; a later wait call can
              be used to again retrieve the child status information.

       Upon successful return, waitid() fills in the following  fields  of
       the siginfo_t structure pointed to by infop:

       si_pid The process ID of the child.

       si_uid The  real  user  ID of the child.  (This field is not set on
              most other implementations.)

       si_signo
              Always set to SIGCHLD.

       si_status
              Either the exit status of the child, as  given  to  _exit(2)
              (or  exit(3)), or the signal that caused the child to termi‐
              nate, stop, or continue.  The si_code field can be  used  to
              determine how to interpret this field.

       si_code
              Set   to   one   of:  CLD_EXITED  (child  called  _exit(2));
              CLD_KILLED  (child  killed  by  signal);  CLD_DUMPED  (child
              killed  by  signal,  and  dumped  core);  CLD_STOPPED (child
              stopped by signal); CLD_TRAPPED (traced child has  trapped);
              or CLD_CONTINUED (child continued by SIGCONT).

       If WNOHANG was specified in options and there were no children in a
       waitable state, then waitid() returns 0 immediately and  the  state
       of  the  siginfo_t structure pointed to by infop depends on the im‐
       plementation.  To (portably) distinguish this case from that  where
       a  child  was in a waitable state, zero out the si_pid field before
       the call and check for a nonzero value in this field after the call
       returns.

       POSIX.1-2008  Technical  Corrigendum  1 (2013) adds the requirement
       that when WNOHANG is specified in options and there were  no  chil‐
       dren  in a waitable state, then waitid() should zero out the si_pid
       and si_signo fields of the structure.  On Linux and other implemen‐
       tations  that  adhere  to  this requirement, it is not necessary to
       zero out the si_pid field before calling  waitid().   However,  not
       all implementations follow the POSIX.1 specification on this point.

RETURN VALUE
       wait(): on success, returns the process ID of the terminated child;
       on error, -1 is returned.

       waitpid(): on success, returns the process ID of  the  child  whose
       state  has  changed;  if  WNOHANG  was  specified  and  one or more
       child(ren) specified by pid exist, but have not yet changed  state,
       then 0 is returned.  On error, -1 is returned.

       waitid():  returns  0 on success or if WNOHANG was specified and no
       child(ren) specified by id has yet changed state; on error,  -1  is
       returned.

       Each  of these calls sets errno to an appropriate value in the case
       of an error.

ERRORS
       ECHILD (for wait()) The calling process does not have any unwaited-
              for children.

       ECHILD (for  waitpid()  or  waitid())  The process specified by pid
              (waitpid()) or idtype and id (waitid()) does not exist or is
              not  a  child  of the calling process.  (This can happen for
              one's own child if the action for SIGCHLD is set to SIG_IGN.
              See also the Linux Notes section about threads.)

       EINTR  WNOHANG was not set and an unblocked signal or a SIGCHLD was
              caught; see signal(7).

       EINVAL The options argument was invalid.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
       A child that terminates, but has not  been  waited  for  becomes  a
       "zombie".   The kernel maintains a minimal set of information about
       the zombie process (PID, termination status, resource usage  infor‐
       mation) in order to allow the parent to later perform a wait to ob‐
       tain information about the child.  As long as a zombie is  not  re‐
       moved  from  the  system  via a wait, it will consume a slot in the
       kernel process table, and if this table fills, it will not be  pos‐
       sible to create further processes.  If a parent process terminates,
       then its "zombie" children (if any) are adopted by init(1), (or  by
       the  nearest  "subreaper" process as defined through the use of the
       prctl(2) PR_SET_CHILD_SUBREAPER operation);  init(1)  automatically
       performs a wait to remove the zombies.

       POSIX.1-2001 specifies that if the disposition of SIGCHLD is set to
       SIG_IGN or the SA_NOCLDWAIT flag is set  for  SIGCHLD  (see  sigac‐
       tion(2)),  then children that terminate do not become zombies and a
       call to wait() or waitpid() will block until all children have ter‐
       minated,  and  then  fail  with errno set to ECHILD.  (The original
       POSIX standard left the behavior of setting SIGCHLD to SIG_IGN  un‐
       specified.   Note  that  even  though  the  default  disposition of
       SIGCHLD is "ignore", explicitly setting the disposition to  SIG_IGN
       results in different treatment of zombie process children.)

       Linux  2.6  conforms to the POSIX requirements.  However, Linux 2.4
       (and earlier) does not: if a wait() or waitpid() call is made while
       SIGCHLD  is  being ignored, the call behaves just as though SIGCHLD
       were not being ignored, that is, the call  blocks  until  the  next
       child terminates and then returns the process ID and status of that
       child.

   Linux notes
       In the Linux kernel, a kernel-scheduled thread is  not  a  distinct
       construct  from  a  process.  Instead, a thread is simply a process
       that is created using the Linux-unique clone(2) system call;  other
       routines  such  as  the  portable pthread_create(3) call are imple‐
       mented using clone(2).  Before Linux 2.4, a thread was just a  spe‐
       cial  case  of a process, and as a consequence one thread could not
       wait on the children of another thread, even when  the  latter  be‐
       longs  to  the  same  thread group.  However, POSIX prescribes such
       functionality, and since Linux 2.4 a thread  can,  and  by  default
       will, wait on children of other threads in the same thread group.

       The following Linux-specific options are for use with children cre‐
       ated using clone(2); they can also, since Linux 4.7, be  used  with
       waitid():

       __WCLONE
              Wait  for  "clone" children only.  If omitted, then wait for
              "non-clone" children only.  (A "clone" child  is  one  which
              delivers  no  signal,  or a signal other than SIGCHLD to its
              parent upon termination.)  This option is ignored if  __WALL
              is also specified.

       __WALL (since Linux 2.4)
              Wait  for all children, regardless of type ("clone" or "non-
              clone").

       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads in the same thread
              group.  This was the default before Linux 2.4.

       Since  Linux  4.7,  the __WALL flag is automatically implied if the
       child is being ptraced.

   C library/kernel differences
       wait() is actually a library function that  (in  glibc)  is  imple‐
       mented as a call to wait4(2).

       On  some architectures, there is no waitpid() system call; instead,
       this interface is implemented via a C library wrapper function that
       calls wait4(2).

       The raw waitid() system call takes a fifth argument, of type struct
       rusage *.  If this argument is non-NULL, then it is used to  return
       resource  usage  information about the child, in the same manner as
       wait4(2).  See getrusage(2) for details.

BUGS
       According to POSIX.1-2008, an application calling waitid() must en‐
       sure that infop points to a siginfo_t structure (i.e., that it is a
       non-null pointer).  On Linux, if infop is NULL, waitid()  succeeds,
       and  returns  the process ID of the waited-for child.  Applications
       should avoid relying on this inconsistent, nonstandard, and  unnec‐
       essary feature.

EXAMPLES
       The  following  program  demonstrates  the use of fork(2) and wait‐
       pid().  The program creates a child process.   If  no  command-line
       argument  is  supplied  to the program, then the child suspends its
       execution using pause(2), to allow the user to send signals to  the
       child.  Otherwise, if a command-line argument is supplied, then the
       child exits immediately, using the integer supplied on the  command
       line  as  the exit status.  The parent process executes a loop that
       monitors the child using waitpid(), and uses the  W*()  macros  de‐
       scribed above to analyze the wait status value.

       The following shell session demonstrates the use of the program:

           $ ./a.out &
           Child PID is 32360
           [1] 32359
           $ kill -STOP 32360
           stopped by signal 19
           $ kill -CONT 32360
           continued
           $ kill -TERM 32360
           killed by signal 15
           [1]+  Done                    ./a.out
           $

   Program source

       #include <sys/wait.h>
       #include <stdint.h>
       #include <stdlib.h>
       #include <unistd.h>
       #include <stdio.h>

       int
       main(int argc, char *argv[])
       {
           pid_t cpid, w;
           int wstatus;

           cpid = fork();
           if (cpid == -1) {
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (cpid == 0) {            /* Code executed by child */
               printf("Child PID is %jd\n", (intmax_t) getpid());
               if (argc == 1)
                   pause();                    /* Wait for signals */
               _exit(atoi(argv[1]));

           } else {                    /* Code executed by parent */
               do {
                   w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);
                   if (w == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(wstatus)) {
                       printf("exited, status=%d\n", WEXITSTATUS(wstatus));
                   } else if (WIFSIGNALED(wstatus)) {
                       printf("killed by signal %d\n", WTERMSIG(wstatus));
                   } else if (WIFSTOPPED(wstatus)) {
                       printf("stopped by signal %d\n", WSTOPSIG(wstatus));
                   } else if (WIFCONTINUED(wstatus)) {
                       printf("continued\n");
                   }
               } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));
               exit(EXIT_SUCCESS);
           }
       }

SEE ALSO
       _exit(2), clone(2), fork(2), kill(2), ptrace(2), sigaction(2), sig‐
       nal(2), wait4(2), pthread_create(3), core(5), credentials(7),  sig‐
       nal(7)

COLOPHON
       This  page  is part of release 5.10 of the Linux man-pages project.
       A description of the project, information about reporting bugs, and
       the    latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-11-01                         WAIT(2)
WAIT4(2)                 Linux Programmer's Manual                WAIT4(2)

NAME
       wait3, wait4 - wait for process to change state, BSD style

SYNOPSIS
       #include <sys/types.h>
       #include <sys/time.h>
       #include <sys/resource.h>
       #include <sys/wait.h>

       pid_t wait3(int *wstatus, int options,
                   struct rusage *rusage);

       pid_t wait4(pid_t pid, int *wstatus, int options,
                   struct rusage *rusage);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       wait3():
           Since glibc 2.26:
               _DEFAULT_SOURCE ||
               (_XOPEN_SOURCE >= 500 &&
                       ! (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >=
       600))
           From glibc 2.19 to 2.25:
               _DEFAULT_SOURCE || _XOPEN_SOURCE >= 500
           Glibc 2.19 and earlier:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500
       wait4():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE

DESCRIPTION
       These functions are nonstandard; in new programs, the use of  wait‐
       pid(2) or waitid(2) is preferable.

       The wait3() and wait4() system calls are similar to waitpid(2), but
       additionally return resource usage information about the  child  in
       the structure pointed to by rusage.

       Other  than  the  use of the rusage argument, the following wait3()
       call:

           wait3(wstatus, options, rusage);

       is equivalent to:

           waitpid(-1, wstatus, options);

       Similarly, the following wait4() call:

           wait4(pid, wstatus, options, rusage);

       is equivalent to:

           waitpid(pid, wstatus, options);

       In other words, wait3() waits of any child, while  wait4()  can  be
       used  to  select  a  specific child, or children, on which to wait.
       See wait(2) for further details.

       If rusage is not NULL, the struct rusage to which it points will be
       filled   with   accounting   information   about  the  child.   See
       getrusage(2) for details.

RETURN VALUE
       As for waitpid(2).

ERRORS
       As for waitpid(2).

CONFORMING TO
       4.3BSD.

       SUSv1 included a specification of wait3(); SUSv2 included  wait3(),
       but marked it LEGACY; SUSv3 removed it.

NOTES
       Including  <sys/time.h>  is  not required these days, but increases
       portability.  (Indeed, <sys/resource.h> defines the  rusage  struc‐
       ture with fields of type struct timeval defined in <sys/time.h>.)

   C library/kernel differences
       On  Linux,  wait3() is a library function implemented on top of the
       wait4() system call.

SEE ALSO
       fork(2), getrusage(2), sigaction(2), signal(2), wait(2), signal(7)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-06-09                        WAIT4(2)
WAIT4(2)                 Linux Programmer's Manual                WAIT4(2)

NAME
       wait3, wait4 - wait for process to change state, BSD style

SYNOPSIS
       #include <sys/types.h>
       #include <sys/time.h>
       #include <sys/resource.h>
       #include <sys/wait.h>

       pid_t wait3(int *wstatus, int options,
                   struct rusage *rusage);

       pid_t wait4(pid_t pid, int *wstatus, int options,
                   struct rusage *rusage);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       wait3():
           Since glibc 2.26:
               _DEFAULT_SOURCE ||
               (_XOPEN_SOURCE >= 500 &&
                       ! (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >=
       600))
           From glibc 2.19 to 2.25:
               _DEFAULT_SOURCE || _XOPEN_SOURCE >= 500
           Glibc 2.19 and earlier:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500
       wait4():
           Since glibc 2.19:
               _DEFAULT_SOURCE
           Glibc 2.19 and earlier:
               _BSD_SOURCE

DESCRIPTION
       These functions are nonstandard; in new programs, the use of  wait‐
       pid(2) or waitid(2) is preferable.

       The wait3() and wait4() system calls are similar to waitpid(2), but
       additionally return resource usage information about the  child  in
       the structure pointed to by rusage.

       Other  than  the  use of the rusage argument, the following wait3()
       call:

           wait3(wstatus, options, rusage);

       is equivalent to:

           waitpid(-1, wstatus, options);

       Similarly, the following wait4() call:

           wait4(pid, wstatus, options, rusage);

       is equivalent to:

           waitpid(pid, wstatus, options);

       In other words, wait3() waits of any child, while  wait4()  can  be
       used  to  select  a  specific child, or children, on which to wait.
       See wait(2) for further details.

       If rusage is not NULL, the struct rusage to which it points will be
       filled   with   accounting   information   about  the  child.   See
       getrusage(2) for details.

RETURN VALUE
       As for waitpid(2).

ERRORS
       As for waitpid(2).

CONFORMING TO
       4.3BSD.

       SUSv1 included a specification of wait3(); SUSv2 included  wait3(),
       but marked it LEGACY; SUSv3 removed it.

NOTES
       Including  <sys/time.h>  is  not required these days, but increases
       portability.  (Indeed, <sys/resource.h> defines the  rusage  struc‐
       ture with fields of type struct timeval defined in <sys/time.h>.)

   C library/kernel differences
       On  Linux,  wait3() is a library function implemented on top of the
       wait4() system call.

SEE ALSO
       fork(2), getrusage(2), sigaction(2), signal(2), wait(2), signal(7)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2020-06-09                        WAIT4(2)
WRITE(2)                 Linux Programmer's Manual                WRITE(2)

NAME
       write - write to a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t write(int fd, const void *buf, size_t count);

DESCRIPTION
       write() writes up to count bytes from the buffer starting at buf to
       the file referred to by the file descriptor fd.

       The number of bytes written may be less than count if, for example,
       there  is  insufficient space on the underlying physical medium, or
       the RLIMIT_FSIZE resource limit is encountered (see  setrlimit(2)),
       or  the call was interrupted by a signal handler after having writ‐
       ten less than count bytes.  (See also pipe(7).)

       For a seekable file (i.e., one to which lseek(2)  may  be  applied,
       for  example,  a regular file) writing takes place at the file off‐
       set, and the file offset is incremented by the number of bytes  ac‐
       tually  written.  If the file was open(2)ed with O_APPEND, the file
       offset is first set to the end of the file before writing.  The ad‐
       justment  of  the file offset and the write operation are performed
       as an atomic step.

       POSIX requires that a read(2) that can be proved to occur  after  a
       write()  has  returned will return the new data.  Note that not all
       filesystems are POSIX conforming.

       According to POSIX.1, if count is greater than SSIZE_MAX,  the  re‐
       sult  is  implementation-defined;  see NOTES for the upper limit on
       Linux.

RETURN VALUE
       On success, the number of bytes written is returned.  On error,  -1
       is returned, and errno is set to indicate the cause of the error.

       Note that a successful write() may transfer fewer than count bytes.
       Such partial writes can occur for various reasons; for example, be‐
       cause  there was insufficient space on the disk device to write all
       of the requested bytes, or because a blocked write() to  a  socket,
       pipe,  or  similar was interrupted by a signal handler after it had
       transferred some, but before it had  transferred  all  of  the  re‐
       quested  bytes.   In  the  event of a partial write, the caller can
       make another write() call to transfer  the  remaining  bytes.   The
       subsequent call will either transfer further bytes or may result in
       an error (e.g., if the disk is now full).

       If count is zero and fd refers to a regular file, then write()  may
       return a failure status if one of the errors below is detected.  If
       no errors are detected, or error detection is not performed, 0 will
       be returned without causing any other effect.  If count is zero and
       fd refers to a file other than a regular file, the results are  not
       specified.

ERRORS
       EAGAIN The  file descriptor fd refers to a file other than a socket
              and has been marked nonblocking (O_NONBLOCK), and the  write
              would  block.  See open(2) for further details on the O_NON‐
              BLOCK flag.

       EAGAIN or EWOULDBLOCK
              The file descriptor fd refers  to  a  socket  and  has  been
              marked  nonblocking (O_NONBLOCK), and the write would block.
              POSIX.1-2001 allows either error to  be  returned  for  this
              case,  and does not require these constants to have the same
              value, so a portable application should check for both  pos‐
              sibilities.

       EBADF  fd  is  not a valid file descriptor or is not open for writ‐
              ing.

       EDESTADDRREQ
              fd refers to a datagram socket for which a peer address  has
              not been set using connect(2).

       EDQUOT The user's quota of disk blocks on the filesystem containing
              the file referred to by fd has been exhausted.

       EFAULT buf is outside your accessible address space.

       EFBIG  An attempt was made to write a file that exceeds the  imple‐
              mentation-defined  maximum  file  size or the process's file
              size limit, or to write at a position past the  maximum  al‐
              lowed offset.

       EINTR  The  call  was  interrupted  by a signal before any data was
              written; see signal(7).

       EINVAL fd is attached to an object which is unsuitable for writing;
              or  the  file  was opened with the O_DIRECT flag, and either
              the address specified in buf, the value specified in  count,
              or the file offset is not suitably aligned.

       EIO    A  low-level  I/O  error occurred while modifying the inode.
              This error may relate to the write-back of data  written  by
              an  earlier write(), which may have been issued to a differ‐
              ent file descriptor on the same file.  Since Linux 4.13, er‐
              rors  from  write-back  come with a promise that they may be
              reported by subsequent.  write() requests, and will  be  re‐
              ported  by  a  subsequent fsync(2) (whether or not they were
              also reported by write()).  An alternate  cause  of  EIO  on
              networked  filesystems  is  when  an  advisory lock had been
              taken out on the file descriptor  and  this  lock  has  been
              lost.   See  the  Lost locks section of fcntl(2) for further
              details.

       ENOSPC The device containing the file referred to by fd has no room
              for the data.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EPIPE  fd  is  connected  to  a pipe or socket whose reading end is
              closed.  When this happens the writing process will also re‐
              ceive  a  SIGPIPE  signal.  (Thus, the write return value is
              seen only if the program catches,  blocks  or  ignores  this
              signal.)

       Other errors may occur, depending on the object connected to fd.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

       Under  SVr4  a  write  may  be  interrupted and return EINTR at any
       point, not just before any data is written.

NOTES
       The types size_t and ssize_t are, respectively, unsigned and signed
       integer data types specified by POSIX.1.

       A  successful  return from write() does not make any guarantee that
       data has been committed to disk.  On  some  filesystems,  including
       NFS,  it  does  not even guarantee that space has successfully been
       reserved for the data.  In this case, some errors might be  delayed
       until  a  future write(), fsync(2), or even close(2).  The only way
       to be sure is to call fsync(2) after you are done writing all  your
       data.

       If  a  write()  is interrupted by a signal handler before any bytes
       are written, then the call fails with the error EINTR; if it is in‐
       terrupted  after  at least one byte has been written, the call suc‐
       ceeds, and returns the number of bytes written.

       On Linux, write() (and similar system calls) will transfer at  most
       0x7ffff000 (2,147,479,552) bytes, returning the number of bytes ac‐
       tually transferred.  (This is true on both 32-bit and  64-bit  sys‐
       tems.)

       An  error  return  value  while performing write() using direct I/O
       does not mean the entire write has  failed.  Partial  data  may  be
       written  and  the  data at the file offset on which the write() was
       attempted should be considered inconsistent.

BUGS
       According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 ("Thread Interac‐
       tions with Regular File Operations"):

           All  of the following functions shall be atomic with respect to
           each other in the effects specified in POSIX.1-2008  when  they
           operate on regular files or symbolic links: ...

       Among  the APIs subsequently listed are write() and writev(2).  And
       among the effects that should be atomic across  threads  (and  pro‐
       cesses)  are  updates of the file offset.  However, on Linux before
       version 3.14, this was not the case: if two processes that share an
       open   file   description  (see  open(2))  perform  a  write()  (or
       writev(2)) at the same time,  then  the  I/O  operations  were  not
       atomic  with respect updating the file offset, with the result that
       the blocks of data output by the two processes might  (incorrectly)
       overlap.  This problem was fixed in Linux 3.14.

SEE ALSO
       close(2),   fcntl(2),   fsync(2),   ioctl(2),   lseek(2),  open(2),
       pwrite(2), read(2), select(2), writev(2), fwrite(3)

COLOPHON
       This page is part of release 5.10 of the Linux  man-pages  project.
       A description of the project, information about reporting bugs, and
       the   latest   version   of   this   page,   can   be   found    at
       https://www.kernel.org/doc/man-pages/.

Linux                           2019-10-10                        WRITE(2)
